(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "./codegen", "./util", "./names"], function (require, exports) {
    {
        KeywordErrorCxt, KeywordErrorDefinition;
    }
    from;
    "../types";
    {
        SchemaCxt;
    }
    from;
    "./index";
    var codegen_1 = require("./codegen");
    var util_1 = require("./util");
    var names_1 = require("./names");
    exports.keywordError = {
        message: function (_a) {
            var keyword = _a.keyword;
            return (_b = ["should pass \"", "\" keyword validation"], _b.raw = ["should pass \"", "\" keyword validation"], codegen_1.str(_b, keyword));
            var _b;
        },
    };
    exports.keyword$DataError = {
        message: function (_a) {
            var keyword = _a.keyword, schemaType = _a.schemaType;
            return schemaType
                ? (_b = ["\"", "\" keyword must be ", " ($data)"], _b.raw = ["\"", "\" keyword must be ", " ($data)"], codegen_1.str(_b, keyword, schemaType))
                : (_c = ["\"", "\" keyword is invalid ($data)"], _c.raw = ["\"", "\" keyword is invalid ($data)"], codegen_1.str(_c, keyword));
            var _b, _c;
        },
    };
    function reportError(cxt, error, errorPaths, overrideAllErrors) {
        if (error === void 0) { error = exports.keywordError; }
        var it = cxt.it;
        var gen = it.gen, compositeRule = it.compositeRule, allErrors = it.allErrors;
        var errObj = errorObjectCode(cxt, error, errorPaths);
        if (overrideAllErrors ?  ? (compositeRule || allErrors) :  : ) {
            addError(gen, errObj);
        }
        else {
            returnErrors(it, (_a = ["[", "]"], _a.raw = ["[", "]"], codegen_1._(_a, errObj)));
        }
        var _a;
    }
    exports.reportError = reportError;
    function reportExtraError(cxt, error, errorPaths) {
        if (error === void 0) { error = exports.keywordError; }
        var it = cxt.it;
        var gen = it.gen, compositeRule = it.compositeRule, allErrors = it.allErrors;
        var errObj = errorObjectCode(cxt, error, errorPaths);
        addError(gen, errObj);
        if (!(compositeRule || allErrors)) {
            returnErrors(it, names_1.default.vErrors);
        }
    }
    exports.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
        gen.assign(names_1.default.errors, errsCount);
        gen.if((_a = ["", " !== null"], _a.raw = ["", " !== null"], codegen_1._(_a, names_1.default.vErrors)), function () {
            return gen.if(errsCount, function () { return gen.assign((_a = ["", ".length"], _a.raw = ["", ".length"], codegen_1._(_a, names_1.default.vErrors)), errsCount); var _a; }, function () { return gen.assign(names_1.default.vErrors, null); });
        });
        var _a;
    }
    exports.resetErrorsCount = resetErrorsCount;
    function extendErrors(_a) {
        var gen = _a.gen, keyword = _a.keyword, schemaValue = _a.schemaValue, data = _a.data, errsCount = _a.errsCount, it = _a.it;
        /* istanbul ignore if */
        if (errsCount === undefined)
            throw new Error("ajv implementation error");
        var err = gen.name("err");
        gen.forRange("i", errsCount, names_1.default.errors, function (i) {
            gen.const(err, (_a = ["", "[", "]"], _a.raw = ["", "[", "]"], codegen_1._(_a, names_1.default.vErrors, i)));
            gen.if((_b = ["", ".instancePath === undefined"], _b.raw = ["", ".instancePath === undefined"], codegen_1._(_b, err)), function () {
                return gen.assign((_a = ["", ".instancePath"], _a.raw = ["", ".instancePath"], codegen_1._(_a, err)), codegen_1.strConcat(names_1.default.instancePath, it.errorPath));
                var _a;
            });
            gen.assign((_c = ["", ".schemaPath"], _c.raw = ["", ".schemaPath"], codegen_1._(_c, err)), (_d = ["", "/", ""], _d.raw = ["", "/", ""], codegen_1.str(_d, it.errSchemaPath, keyword)));
            if (it.opts.verbose) {
                gen.assign((_e = ["", ".schema"], _e.raw = ["", ".schema"], codegen_1._(_e, err)), schemaValue);
                gen.assign((_f = ["", ".data"], _f.raw = ["", ".data"], codegen_1._(_f, err)), data);
            }
            var _a, _b, _c, _d, _e, _f;
        });
    }
    exports.extendErrors = extendErrors;
    function addError(gen, errObj) {
        var err = gen.const("err", errObj);
        gen.if((_a = ["", " === null"], _a.raw = ["", " === null"], codegen_1._(_a, names_1.default.vErrors)), function () { return gen.assign(names_1.default.vErrors, (_a = ["[", "]"], _a.raw = ["[", "]"], codegen_1._(_a, err))); var _a; }, (_b = ["", ".push(", ")"], _b.raw = ["", ".push(", ")"], codegen_1._(_b, names_1.default.vErrors, err)));
        gen.code((_c = ["", "++"], _c.raw = ["", "++"], codegen_1._(_c, names_1.default.errors)));
        var _a, _b, _c;
    }
    function returnErrors(it, errs) {
        var gen = it.gen, validateName = it.validateName, schemaEnv = it.schemaEnv;
        if (schemaEnv.$async) {
            gen.throw((_a = ["new ", ""], _a.raw = ["new ", ""], codegen_1._(_a, it.ValidationError)), as, codegen_1.Name);
        }
        ($);
        {
            errs;
        }
        ")\n  } else {\n    gen.assign(_";
        $;
        {
            validateName;
        }
        (_b = [", errs)\n    gen.return(false)\n  }\n}\n\nconst E = {\n  keyword: new Name(\"keyword\"),\n  schemaPath: new Name(\"schemaPath\"), // also used in JTD errors\n  params: new Name(\"params\"),\n  propertyName: new Name(\"propertyName\"),\n  message: new Name(\"message\"),\n  schema: new Name(\"schema\"),\n  parentSchema: new Name(\"parentSchema\"),\n}\n\nfunction errorObjectCode(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths?: ErrorPaths\n): Code {\n  const {createErrors} = cxt.it\n  if (createErrors === false) return _"], _b.raw = [", errs)\n    gen.return(false)\n  }\n}\n\nconst E = {\n  keyword: new Name(\"keyword\"),\n  schemaPath: new Name(\"schemaPath\"), // also used in JTD errors\n  params: new Name(\"params\"),\n  propertyName: new Name(\"propertyName\"),\n  message: new Name(\"message\"),\n  schema: new Name(\"schema\"),\n  parentSchema: new Name(\"parentSchema\"),\n}\n\nfunction errorObjectCode(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths?: ErrorPaths\n): Code {\n  const {createErrors} = cxt.it\n  if (createErrors === false) return _"], errors(_b));
        { }
        "\n  return errorObject(cxt, error, errorPaths)\n}\n\nfunction errorObject(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths: ErrorPaths = {}\n): Code {\n  const {gen, it} = cxt\n  const keyValues: [Name, SafeExpr | string][] = [\n    errorInstancePath(it, errorPaths),\n    errorSchemaPath(cxt, errorPaths),\n  ]\n  extraErrorProps(cxt, error, keyValues)\n  return gen.object(...keyValues)\n}\n\nfunction errorInstancePath({errorPath}: SchemaCxt, {instancePath}: ErrorPaths): [Name, Code] {\n  const instPath = instancePath\n    ? str";
        $;
        {
            errorPath;
        }
        $;
        {
            util_1.getErrorPath(instancePath, util_1.Type.Str);
        }
        "\n    : errorPath\n  return [N.instancePath, strConcat(N.instancePath, instPath)]\n}\n\nfunction errorSchemaPath(\n  {keyword, it: {errSchemaPath}}: KeywordErrorCxt,\n  {schemaPath, parentSchema}: ErrorPaths\n): [Name, string | Code] {\n  let schPath = parentSchema ? errSchemaPath : str";
        $;
        {
            errSchemaPath;
        }
        /${keyword}`;
        if (schemaPath) {
            schPath = (_c = ["", "", ""], _c.raw = ["", "", ""], codegen_1.str(_c, schPath, util_1.getErrorPath(schemaPath, util_1.Type.Str)));
        }
        return [E.schemaPath, schPath];
        var _a, _b, _c;
    }
    function extraErrorProps(cxt, _a, keyValues) {
        var params = _a.params, message = _a.message;
        var keyword = cxt.keyword, data = cxt.data, schemaValue = cxt.schemaValue, it = cxt.it;
        var opts = it.opts, propertyName = it.propertyName, topSchemaRef = it.topSchemaRef, schemaPath = it.schemaPath;
        keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (_b = ["{}"], _b.raw = ["{}"], codegen_1._(_b))]);
        if (opts.messages) {
            keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
        }
        if (opts.verbose) {
            keyValues.push([E.schema, schemaValue], [E.parentSchema, (_c = ["", "", ""], _c.raw = ["", "", ""], codegen_1._(_c, topSchemaRef, schemaPath))], [names_1.default.data, data]);
        }
        if (propertyName)
            keyValues.push([E.propertyName, propertyName]);
        var _b, _c;
    }
});
