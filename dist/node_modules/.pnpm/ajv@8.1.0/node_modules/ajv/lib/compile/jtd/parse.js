(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "./types", "..", "../codegen", "../ref_error", "../names", "../../vocabularies/code", "../../vocabularies/jtd/ref", "../../vocabularies/jtd/type", "../../runtime/parseJson", "../util", "../../runtime/timestamp"], function (require, exports) {
    from;
    "../../core";
    {
        SchemaObject;
    }
    from;
    "../../types";
    var types_1 = require("./types");
    var __1 = require("..");
    var codegen_1 = require("../codegen");
    var ref_error_1 = require("../ref_error");
    var names_1 = require("../names");
    var code_1 = require("../../vocabularies/code");
    var ref_1 = require("../../vocabularies/jtd/ref");
    var type_1 = require("../../vocabularies/jtd/type");
    var parseJson_1 = require("../../runtime/parseJson");
    var util_1 = require("../util");
    var timestamp_1 = require("../../runtime/timestamp");
    var genParse = {
        elements: parseElements,
        values: parseValues,
        discriminator: parseDiscriminator,
        properties: parseProperties,
        optionalProperties: parseProperties,
        enum: parseEnum,
        type: parseType,
        ref: parseRef,
    };
    readonly;
    gen: codegen_1.CodeGen;
    readonly;
    self: Ajv; // current Ajv instance
    readonly;
    schemaEnv: __1.SchemaEnv;
    readonly;
    definitions: SchemaObjectMap;
    schema: SchemaObject;
    data: codegen_1.Code;
    parseName: codegen_1.Name;
    char: codegen_1.Name;
    this;
    Ajv,
        sch;
    __1.SchemaEnv,
        definitions;
    SchemaObjectMap;
    __1.SchemaEnv;
    {
        var _sch = __1.getCompilingSchema.call(this, sch);
        if (_sch)
            return _sch;
        var _a = this.opts.code, es5 = _a.es5, lines = _a.lines;
        var ownProperties = this.opts.ownProperties;
        var gen = new codegen_1.CodeGen(this.scope, { es5: es5, lines: lines, ownProperties: ownProperties });
        var parseName = gen.scopeName("parse");
        var cxt = {
            self: this,
            gen: gen,
            schema: sch.schema, as: SchemaObject,
            schemaEnv: sch,
            definitions: definitions,
            data: names_1.default.data,
            parseName: parseName,
            char: gen.name("c"),
        };
        var sourceCode;
        try {
            this._compilations.add(sch);
            sch.parseName = parseName;
            parserFunction(cxt);
            gen.optimize(this.opts.code.optimize);
            var parseFuncCode = gen.toString();
            sourceCode = gen.scopeRefs(names_1.default.scope) + "return " + parseFuncCode;
            var makeParse = new Function("" + names_1.default.scope, sourceCode);
            var parse = makeParse(this.scope.get());
            this.scope.value(parseName, { ref: parse });
            sch.parse = parse;
        }
        catch (e) {
            if (sourceCode)
                this.logger.error("Error compiling parser, function code:", sourceCode);
            delete sch.parse;
            delete sch.parseName;
            throw e;
        }
        finally {
            this._compilations.delete(sch);
        }
        return sch;
    }
    var undef = (_b = ["undefined"], _b.raw = ["undefined"], codegen_1._(_b));
    function parserFunction(cxt) {
        var gen = cxt.gen, parseName = cxt.parseName, char = cxt.char;
        gen.func(parseName, (_a = ["", ", ", ", ", ""], _a.raw = ["", ", ", ", ", ""], codegen_1._(_a, names_1.default.json, names_1.default.jsonPos, names_1.default.jsonPart)), false, function () {
            gen.let(names_1.default.data);
            gen.let(char);
            gen.assign((_a = ["", ".message"], _a.raw = ["", ".message"], codegen_1._(_a, parseName)), undef);
            gen.assign((_b = ["", ".position"], _b.raw = ["", ".position"], codegen_1._(_b, parseName)), undef);
            gen.assign(names_1.default.jsonPos, (_c = ["", " || 0"], _c.raw = ["", " || 0"], codegen_1._(_c, names_1.default.jsonPos)));
            gen.const(names_1.default.jsonLen, (_d = ["", ".length"], _d.raw = ["", ".length"], codegen_1._(_d, names_1.default.json)));
            parseCode(cxt);
            skipWhitespace(cxt);
            gen.if(names_1.default.jsonPart, function () {
                gen.assign((_a = ["", ".position"], _a.raw = ["", ".position"], codegen_1._(_a, parseName)), names_1.default.jsonPos);
                gen.return(names_1.default.data);
                var _a;
            });
            gen.if((_e = ["", " === ", ""], _e.raw = ["", " === ", ""], codegen_1._(_e, names_1.default.jsonPos, names_1.default.jsonLen)), function () { return gen.return(names_1.default.data); });
            jsonSyntaxError(cxt);
            var _a, _b, _c, _d, _e;
        });
        var _a;
    }
    function parseCode(cxt) {
        var form;
        for (var _i = 0; _i < types_1.jtdForms.length; _i++) {
            var key = types_1.jtdForms[_i];
            if (key in cxt.schema) {
                form = key;
                break;
            }
        }
        if (form)
            parseNullable(cxt, genParse[form]);
        else
            parseEmpty(cxt);
    }
    var parseBoolean = parseBooleanToken(true, parseBooleanToken(false, jsonSyntaxError));
    function parseNullable(cxt, parseForm) {
        var gen = cxt.gen, schema = cxt.schema, data = cxt.data;
        if (!schema.nullable)
            return parseForm(cxt);
        tryParseToken(cxt, "null", parseForm, function () { return gen.assign(data, null); });
    }
    function parseElements(cxt) {
        var gen = cxt.gen, schema = cxt.schema, data = cxt.data;
        parseToken(cxt, "[");
        var ix = gen.let("i", 0);
        gen.assign(data, (_a = ["[]"], _a.raw = ["[]"], codegen_1._(_a)));
        parseItems(cxt, "]", function () {
            var el = gen.let("el");
            parseCode.apply(void 0, [{}].concat(cxt, [schema, schema.elements, data, el]));
        });
        gen.assign((_b = ["", "[", "++]"], _b.raw = ["", "[", "++]"], codegen_1._(_b, data, ix)), el);
        var _a, _b;
    }
    function parseValues(cxt) {
        var gen = cxt.gen, schema = cxt.schema, data = cxt.data;
        parseToken(cxt, "{");
        gen.assign(data, (_a = ["{}"], _a.raw = ["{}"], codegen_1._(_a)));
        parseItems(cxt, "}", function () { return parseKeyValue(cxt, schema.values); });
        var _a;
    }
    function parseItems(cxt, endToken, block) {
        tryParseItems(cxt, endToken, block);
        parseToken(cxt, endToken);
    }
    function tryParseItems(cxt, endToken, block) {
        var gen = cxt.gen;
        gen.for((_a = [";", "<", " && ", "!==", ";"], _a.raw = [";", "<", " && ", "!==", ";"], codegen_1._(_a, names_1.default.jsonPos, names_1.default.jsonLen, jsonSlice(1), endToken)), function () {
            block();
            tryParseToken(cxt, ",", function () { return gen.break(); }, hasItem);
        });
        function hasItem() {
            tryParseToken(cxt, endToken, function () { }, jsonSyntaxError);
        }
        var _a;
    }
    function parseKeyValue(cxt, schema) {
        var gen = cxt.gen;
        var key = gen.let("key");
        parseString.apply(void 0, [{}].concat(cxt, [data, key]));
    }
    parseToken(cxt, ":");
    parsePropertyValue(cxt, key, schema);
    function parseDiscriminator(cxt) {
        var gen = cxt.gen, data = cxt.data, schema = cxt.schema;
        var discriminator = schema.discriminator, mapping = schema.mapping;
        parseToken(cxt, "{");
        gen.assign(data, (_a = ["{}"], _a.raw = ["{}"], codegen_1._(_a)));
        var startPos = gen.const("pos", names_1.default.jsonPos);
        var value = gen.let("value");
        var tag = gen.let("tag");
        tryParseItems(cxt, "}", function () {
            var key = gen.let("key");
            parseString.apply(void 0, [{}].concat(cxt, [data, key]));
        });
        parseToken(cxt, ":");
        gen.if((_b = ["", " === ", ""], _b.raw = ["", " === ", ""], codegen_1._(_b, key, discriminator)), function () {
            parseString.apply(void 0, [{}].concat(cxt, [data, tag]));
        });
        gen.assign((_c = ["", "[", "]"], _c.raw = ["", "[", "]"], codegen_1._(_c, data, key)), tag);
        gen.break();
        var _a, _b, _c;
    }
    (function () { return parseEmpty.apply(void 0, [{}].concat(cxt, [data, value])); }); // can be discarded/skipped
    gen.assign(names_1.default.jsonPos, startPos);
    gen.if((_c = ["", " === undefined"], _c.raw = ["", " === undefined"], codegen_1._(_c, tag)));
    parsingError(cxt, (_d = ["discriminator tag not found"], _d.raw = ["discriminator tag not found"], codegen_1.str(_d)));
    for (var tagValue in mapping) {
        gen.elseIf((_e = ["", " === ", ""], _e.raw = ["", " === ", ""], codegen_1._(_e, tag, tagValue)));
        parseSchemaProperties.apply(void 0, [{}].concat(cxt, [schema, mapping[tagValue]]));
    }
    discriminator;
    gen.else();
    parsingError(cxt, (_f = ["discriminator value not in schema"], _f.raw = ["discriminator value not in schema"], codegen_1.str(_f)));
    gen.endIf();
    function parseProperties(cxt) {
        var gen = cxt.gen, data = cxt.data;
        parseToken(cxt, "{");
        gen.assign(data, (_a = ["{}"], _a.raw = ["{}"], codegen_1._(_a)));
        parseSchemaProperties(cxt);
        var _a;
    }
    function parseSchemaProperties(cxt, discriminator) {
        var gen = cxt.gen, schema = cxt.schema, data = cxt.data;
        var properties = schema.properties, optionalProperties = schema.optionalProperties, additionalProperties = schema.additionalProperties;
        parseItems(cxt, "}", function () {
            var key = gen.let("key");
            parseString.apply(void 0, [{}].concat(cxt, [data, key]));
        });
        parseToken(cxt, ":");
        gen.if(false);
        parseDefinedProperty(cxt, key, properties);
        parseDefinedProperty(cxt, key, optionalProperties);
        if (discriminator) {
            gen.elseIf((_a = ["", " === ", ""], _a.raw = ["", " === ", ""], codegen_1._(_a, key, discriminator)));
            var tag = gen.let("tag");
            parseString.apply(void 0, [{}].concat(cxt, [data, tag]));
        }
        var _a;
    }
    gen.else();
    if (additionalProperties) {
        parseEmpty.apply(void 0, [{}].concat(cxt, [data, (_g = ["", "[", "]"], _g.raw = ["", "[", "]"], codegen_1._(_g, data, key))]));
    }
    {
        parsingError(cxt, (_h = ["property ", " not allowed"], _h.raw = ["property ", " not allowed"], codegen_1.str(_h, key)));
    }
    gen.endIf();
    if (properties) {
        var hasProp = code_1.hasPropFunc(gen);
        var allProps = codegen_1.and.apply(void 0, Object.keys(properties).map(function (p) { return (_a = ["", ".call(", ", ", ")"], _a.raw = ["", ".call(", ", ", ")"], codegen_1._(_a, hasProp, data, p)); var _a; }));
        gen.if(codegen_1.not(allProps), function () { return parsingError(cxt, (_a = ["missing required properties"], _a.raw = ["missing required properties"], codegen_1.str(_a))); var _a; });
    }
    function parseDefinedProperty(cxt, key, schemas) {
        if (schemas === void 0) { schemas = {}; }
        var gen = cxt.gen;
        for (var prop in schemas) {
            gen.elseIf((_a = ["", " === ", ""], _a.raw = ["", " === ", ""], codegen_1._(_a, key, prop)));
            parsePropertyValue(cxt, key, schemas[prop], as, SchemaObject);
        }
        var _a;
    }
    function parsePropertyValue(cxt, key, schema) {
        parseCode.apply(void 0, [{}].concat(cxt, [schema, data, (_a = ["", "[", "]"], _a.raw = ["", "[", "]"], codegen_1._(_a, cxt.data, key))]));
        var _a;
    }
    function parseType(cxt) {
        var gen = cxt.gen, schema = cxt.schema, data = cxt.data;
        switch (schema.type) {
            case "boolean":
                parseBoolean(cxt);
                break;
            case "string":
                parseString(cxt);
                break;
            case "timestamp": {
                // TODO parse timestamp?
                parseString(cxt);
                var vts = util_1.useFunc(gen, timestamp_1.default);
                gen.if((_a = ["!", "(", ")"], _a.raw = ["!", "(", ")"], codegen_1._(_a, vts, data)), function () { return parsingError(cxt, (_a = ["invalid timestamp"], _a.raw = ["invalid timestamp"], codegen_1.str(_a))); var _a; });
                break;
            }
            case "float32":
            case "float64":
                parseNumber(cxt);
                break;
            default: {
                var _b = type_1.intRange[schema.type], min = _b[0], max = _b[1], maxDigits = _b[2], as = IntType, parseNumber_1 = (cxt, maxDigits);
                gen.if((_c = ["", " < ", " || ", " > ", ""], _c.raw = ["", " < ", " || ", " > ", ""], codegen_1._(_c, data, min, data, max)), function () {
                    return parsingError(cxt, (_a = ["integer out of range"], _a.raw = ["integer out of range"], codegen_1.str(_a)));
                    var _a;
                });
            }
        }
        var _a, _c;
    }
    function parseString(cxt) {
        parseToken(cxt, '"');
        parseWith(cxt, parseJson_1.parseJsonString);
    }
    function parseEnum(cxt) {
        var gen = cxt.gen, data = cxt.data, schema = cxt.schema;
        var enumSch = schema.enum;
        parseToken(cxt, '"');
        // TODO loopEnum
        gen.if(false);
        for (var _i = 0; _i < enumSch.length; _i++) {
            var value = enumSch[_i];
            var valueStr = JSON.stringify(value).slice(1); // remove starting quote
            gen.elseIf((_a = ["", " === ", ""], _a.raw = ["", " === ", ""], codegen_1._(_a, jsonSlice(valueStr.length), valueStr)));
            gen.assign(data, (_b = ["", ""], _b.raw = ["", ""], codegen_1.str(_b, value)));
            gen.add(names_1.default.jsonPos, valueStr.length);
        }
        gen.else();
        jsonSyntaxError(cxt);
        gen.endIf();
        var _a, _b;
    }
    function parseNumber(cxt, maxDigits) {
        var gen = cxt.gen;
        skipWhitespace(cxt);
        gen.if((_a = ["\"-0123456789\".indexOf(", ") < 0"], _a.raw = ["\"-0123456789\".indexOf(", ") < 0"], codegen_1._(_a, jsonSlice(1))), function () { return jsonSyntaxError(cxt); }, function () { return parseWith(cxt, parseJson_1.parseJsonNumber, maxDigits); });
        var _a;
    }
    function parseBooleanToken(bool, fail) {
        return function (cxt) {
            var gen = cxt.gen, data = cxt.data;
            tryParseToken(cxt, "" + bool, function () { return fail(cxt); }, function () { return gen.assign(data, bool); });
        };
    }
    function parseRef(cxt) {
        var gen = cxt.gen, self = cxt.self, definitions = cxt.definitions, schema = cxt.schema, schemaEnv = cxt.schemaEnv;
        var ref = schema.ref;
        var refSchema = definitions[ref];
        if (!refSchema)
            throw new ref_error_1.default("", ref, "No definition " + ref);
        if (!ref_1.hasRef(refSchema))
            return parseCode.apply(void 0, [{}].concat(cxt, [schema, refSchema]));
    }
    var root = schemaEnv.root;
    var sch = compileParser.call(self, new __1.SchemaEnv({ schema: refSchema, root: root }), definitions);
    partialParse(cxt, getParser(gen, sch), true);
    function getParser(gen, sch) {
        return sch.parse
            ? gen.scopeValue("parse", { ref: sch.parse })
            : (_a = ["", ".parse"], _a.raw = ["", ".parse"], codegen_1._(_a, gen.scopeValue("wrapper", { ref: sch })));
        var _a;
    }
    function parseEmpty(cxt) {
        parseWith(cxt, parseJson_1.parseJson);
    }
    function parseWith(cxt, parseFunc, args) {
        partialParse(cxt, util_1.useFunc(cxt.gen, parseFunc), args);
    }
    function partialParse(cxt, parseFunc, args) {
        var gen = cxt.gen, data = cxt.data;
        gen.assign(data, (_a = ["", "(", ", ", "", ")"], _a.raw = ["", "(", ", ", "", ")"], codegen_1._(_a, parseFunc, names_1.default.json, names_1.default.jsonPos, args ? (_b = [", ", ""], _b.raw = [", ", ""], codegen_1._(_b, args)) : codegen_1.nil)));
        gen.assign(names_1.default.jsonPos, (_c = ["", ".position"], _c.raw = ["", ".position"], codegen_1._(_c, parseFunc)));
        gen.if((_d = ["", " === undefined"], _d.raw = ["", " === undefined"], codegen_1._(_d, data)), function () { return parsingError(cxt, (_a = ["", ".message"], _a.raw = ["", ".message"], codegen_1._(_a, parseFunc))); var _a; });
        var _a, _b, _c, _d;
    }
    function parseToken(cxt, tok) {
        tryParseToken(cxt, tok, jsonSyntaxError);
    }
    function tryParseToken(cxt, tok, fail, success) {
        var gen = cxt.gen;
        var n = tok.length;
        skipWhitespace(cxt);
        gen.if((_a = ["", " === ", ""], _a.raw = ["", " === ", ""], codegen_1._(_a, jsonSlice(n), tok)), function () {
            gen.add(names_1.default.jsonPos, n);
            success ? .(cxt)
                :
            ;
        }, function () { return fail(cxt); });
        var _a;
    }
    function skipWhitespace(_a) {
        var gen = _a.gen, c = _a.char;
        gen.code((_b = ["while((", "=", "[", "],", "===\" \"||", "===\"\\n\"||", "===\"\\r\"||", "===\"\\t\"))", "++;"], _b.raw = ["while((", "=", "[", "],", "===\" \"||", "===\"\\\\n\"||", "===\"\\\\r\"||", "===\"\\\\t\"))", "++;"], codegen_1._(_b, c, names_1.default.json, names_1.default.jsonPos, c, c, c, c, names_1.default.jsonPos)));
        var _b;
    }
    function jsonSlice(len) {
        return len === 1
            ? (_a = ["", "[", "]"], _a.raw = ["", "[", "]"], codegen_1._(_a, names_1.default.json, names_1.default.jsonPos))
            : (_b = ["", ".slice(", ", ", "+", ")"], _b.raw = ["", ".slice(", ", ", "+", ")"], codegen_1._(_b, names_1.default.json, names_1.default.jsonPos, names_1.default.jsonPos, len));
        var _a, _b;
    }
    function jsonSyntaxError(cxt) {
        parsingError(cxt, (_a = ["\"unexpected token \" + ", "[", "]"], _a.raw = ["\"unexpected token \" + ", "[", "]"], codegen_1._(_a, names_1.default.json, names_1.default.jsonPos)));
        var _a;
    }
    function parsingError(_a, msg) {
        var gen = _a.gen, parseName = _a.parseName;
        gen.assign((_b = ["", ".message"], _b.raw = ["", ".message"], codegen_1._(_b, parseName)), msg);
        gen.assign((_c = ["", ".position"], _c.raw = ["", ".position"], codegen_1._(_c, parseName)), names_1.default.jsonPos);
        gen.return(undef);
        var _b, _c;
    }
    var _b, _c, _d, _e, _f, _g, _h;
});
