(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "./codegen", "./codegen/code"], function (require, exports) {
    {
        AnySchema, EvaluatedProperties, EvaluatedItems;
    }
    from;
    "../types";
    {
        SchemaCxt, SchemaObjCxt;
    }
    from;
    ".";
    var codegen_1 = require("./codegen");
    var code_1 = require("./codegen/code");
    {
        Rule, ValidationRules;
    }
    from;
    "./rules";
    // TODO refactor to use Set
    function toHash(arr) {
        var hash = {};
        for (var _i = 0; _i < arr.length; _i++) {
            var item = arr[_i];
            hash[item] = true;
        }
        return hash;
    }
    exports.toHash = toHash;
    function alwaysValidSchema(it, schema) {
        if (typeof schema == "boolean")
            return schema;
        if (Object.keys(schema).length === 0)
            return true;
        checkUnknownRules(it, schema);
        return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema) {
        if (schema === void 0) { schema = it.schema; }
        var opts = it.opts, self = it.self;
        if (!opts.strictSchema)
            return;
        if (typeof schema === "boolean")
            return;
        var rules = self.RULES.keywords;
        for (var key in schema) {
            if (!rules[key])
                checkStrictMode(it, "unknown keyword: \"" + key + "\"");
        }
    }
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
        if (typeof schema == "boolean")
            return !schema;
        for (var key in schema)
            if (rules[key])
                return true;
        return false;
    }
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
        if (typeof schema == "boolean")
            return !schema;
        for (var key in schema)
            if (key !== "$ref" && RULES.all[key])
                return true;
        return false;
    }
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal(_a, schema, keyword, $data) {
        var topSchemaRef = _a.topSchemaRef, schemaPath = _a.schemaPath;
        if ($data === void 0) { $data = false; }
        if (!$data) {
            if (typeof schema == "number" || typeof schema == "boolean")
                return schema;
            if (typeof schema == "string")
                return (_b = ["", ""], _b.raw = ["", ""], codegen_1._(_b, schema));
        }
        return (_c = ["", "", "", ""], _c.raw = ["", "", "", ""], codegen_1._(_c, topSchemaRef, schemaPath, codegen_1.getProperty(keyword)));
        var _b, _c;
    }
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
        return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
        return encodeURIComponent(escapeJsonPointer(str));
    }
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
        if (typeof str == "number")
            return "" + str;
        return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
        return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
        if (Array.isArray(xs)) {
            for (var _i = 0; _i < xs.length; _i++) {
                var x = xs[_i];
                f(x);
            }
        }
        else {
            f(xs);
        }
    }
    exports.eachItem = eachItem;
    function makeMergeEvaluated(_a) {
        var mergeNames = _a.mergeNames, mergeToName = _a.mergeToName, mergeValues = _a.mergeValues, resultToName = _a.resultToName;
        return function (gen, from, to, toName) {
            var res = to === undefined
                ? from
                : to instanceof codegen_1.Name
                    ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)
                    : from instanceof codegen_1.Name
                        ? (mergeToName(gen, to, from), from)
                        : mergeValues(from, to);
            return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
        };
    }
    exports.mergeEvaluated = {
        props: makeMergeEvaluated.apply(void 0, [{
            mergeNames: function (gen, from, to) {
                return gen.if((_a = ["", " !== true && ", " !== undefined"], _a.raw = ["", " !== true && ", " !== undefined"], codegen_1._(_a, to, from)), function () {
                    gen.if((_a = ["", " === true"], _a.raw = ["", " === true"], codegen_1._(_a, from)), function () { return gen.assign(to, true); }, function () { return gen.assign(to, (_a = ["", " || {}"], _a.raw = ["", " || {}"], codegen_1._(_a, to))).code((_b = ["Object.assign(", ", ", ")"], _b.raw = ["Object.assign(", ", ", ")"], codegen_1._(_b, to, from))); var _a, _b; });
                    var _a;
                });
                var _a;
            },
            mergeToName: function (gen, from, to) {
                return gen.if((_a = ["", " !== true"], _a.raw = ["", " !== true"], codegen_1._(_a, to)), function () {
                    if (from === true) {
                        gen.assign(to, true);
                    }
                    else {
                        gen.assign(to, (_a = ["", " || {}"], _a.raw = ["", " || {}"], codegen_1._(_a, to)));
                        setEvaluated(gen, to, from);
                    }
                    var _a;
                });
                var _a;
            },
            mergeValues: function (from, to) { return (from === true ? true : {}); } }].concat(from, to)) };
    items: makeMergeEvaluated({
        mergeNames: function (gen, from, to) {
            return gen.if((_a = ["", " !== true && ", " !== undefined"], _a.raw = ["", " !== true && ", " !== undefined"], codegen_1._(_a, to, from)), function () {
                return gen.assign(to, (_a = ["", " === true ? true : ", " > ", " ? ", " : ", ""], _a.raw = ["", " === true ? true : ", " > ", " ? ", " : ", ""], codegen_1._(_a, from, to, from, to, from)));
                var _a;
            });
            var _a;
        },
        mergeToName: function (gen, from, to) {
            return gen.if((_a = ["", " !== true"], _a.raw = ["", " !== true"], codegen_1._(_a, to)), function () {
                return gen.assign(to, from === true ? true : (_a = ["", " > ", " ? ", " : ", ""], _a.raw = ["", " > ", " ? ", " : ", ""], codegen_1._(_a, to, from, to, from)));
                var _a;
            });
            var _a;
        },
        mergeValues: function (from, to) { return (from === true ? true : Math.max(from, to)); },
        resultToName: function (gen, items) { return gen.var("items", items); },
    }),
    ;
    function evaluatedPropsToName(gen, ps) {
        if (ps === true)
            return gen.var("props", true);
        var props = gen.var("props", (_a = ["{}"], _a.raw = ["{}"], codegen_1._(_a)));
        if (ps !== undefined)
            setEvaluated(gen, props, ps);
        return props;
        var _a;
    }
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
        Object.keys(ps).forEach(function (p) { return gen.assign((_a = ["", "", ""], _a.raw = ["", "", ""], codegen_1._(_a, props, codegen_1.getProperty(p))), true); var _a; });
    }
    exports.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
        return gen.scopeValue("func", {
            ref: f,
            code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),
        });
    }
    exports.useFunc = useFunc;
    (function (Type) {
        Type[Type["Num"] = 0] = "Num";
        Type[Type["Str"] = 1] = "Str";
    })(exports.Type || (exports.Type = {}));
    var Type = exports.Type;
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
        // let path
        if (dataProp instanceof codegen_1.Name) {
            var isNumber = dataPropType === Type.Num;
            return jsPropertySyntax
                ? isNumber
                    ? (_a = ["\"[\" + ", " + \"]\""], _a.raw = ["\"[\" + ", " + \"]\""], codegen_1._(_a, dataProp))
                    : (_b = ["\"['\" + ", " + \"']\""], _b.raw = ["\"['\" + ", " + \"']\""], codegen_1._(_b, dataProp))
                : isNumber
                    ? (_c = ["\"/\" + ", ""], _c.raw = ["\"/\" + ", ""], codegen_1._(_c, dataProp))
                    : (_d = ["\"/\" + ", ".replace(/~/g, \"~0\").replace(/\\//g, \"~1\")"], _d.raw = ["\"/\" + ", ".replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")"], codegen_1._(_d, dataProp)); // TODO maybe use global escapePointer
        }
        return jsPropertySyntax ? codegen_1.getProperty(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
        var _a, _b, _c, _d;
    }
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode) {
        if (mode === void 0) { mode = "log" = it.opts.strictSchema; }
        if (!mode)
            return;
        msg = "strict mode: " + msg;
        if (mode === true)
            throw new Error(msg);
        it.self.logger.warn(msg);
    }
    exports.checkStrictMode = checkStrictMode;
});
