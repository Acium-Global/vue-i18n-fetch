(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "../rules", "./applicability", "../errors", "../codegen", "../util"], function (require, exports) {
    {
        KeywordErrorDefinition,
            KeywordErrorCxt,
            ErrorObject,
            AnySchemaObject,
        ;
    }
    from;
    "../../types";
    {
        SchemaObjCxt;
    }
    from;
    "..";
    var rules_1 = require("../rules");
    var applicability_1 = require("./applicability");
    var errors_1 = require("../errors");
    var codegen_1 = require("../codegen");
    var util_1 = require("../util");
    (function (DataType) {
        DataType[DataType["Correct"] = 0] = "Correct";
        DataType[DataType["Wrong"] = 1] = "Wrong";
    })(exports.DataType || (exports.DataType = {}));
    var DataType = exports.DataType;
    function getSchemaTypes(schema) {
        var types = getJSONTypes(schema.type);
        var hasNull = types.includes("null");
        if (hasNull) {
            if (schema.nullable === false)
                throw new Error("type: null contradicts nullable: false");
        }
        else {
            if (!types.length && schema.nullable !== undefined) {
                throw new Error('"nullable" cannot be used without "type"');
            }
            if (schema.nullable === true)
                types.push("null");
        }
        return types;
    }
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
        var types = Array.isArray(ts) ? ts : ts ? [ts] : [];
        if (types.every(rules_1.isJSONType))
            return types;
        throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
        var gen = it.gen, data = it.data, opts = it.opts;
        var coerceTo = coerceToTypes(types, opts.coerceTypes);
        var checkTypes = types.length > 0 &&
            !(coerceTo.length === 0 && types.length === 1 && applicability_1.schemaHasRulesForType(it, types[0]));
        if (checkTypes) {
            var wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
            gen.if(wrongType, function () {
                if (coerceTo.length)
                    coerceData(it, types, coerceTo);
                else
                    reportTypeError(it);
            });
        }
        return checkTypes;
    }
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
        if (coerceTypes === void 0) { coerceTypes = "array"; }
        return coerceTypes
            ? types.filter(function (t) { return COERCIBLE.has(t) || (coerceTypes === "array" && t === "array"); })
            : [];
    }
    function coerceData(it, types, coerceTo) {
        var gen = it.gen, data = it.data, opts = it.opts;
        var dataType = gen.let("dataType", (_a = ["typeof ", ""], _a.raw = ["typeof ", ""], codegen_1._(_a, data)));
        var coerced = gen.let("coerced", (_b = ["undefined"], _b.raw = ["undefined"], codegen_1._(_b)));
        if (opts.coerceTypes === "array") {
            gen.if((_c = ["", " == 'object' && Array.isArray(", ") && ", ".length == 1"], _c.raw = ["", " == 'object' && Array.isArray(", ") && ", ".length == 1"], codegen_1._(_c, dataType, data, data)), function () {
                return gen
                    .assign(data, (_a = ["", "[0]"], _a.raw = ["", "[0]"], codegen_1._(_a, data)))
                    .assign(dataType, (_b = ["typeof ", ""], _b.raw = ["typeof ", ""], codegen_1._(_b, data)))
                    .if(checkDataTypes(types, data, opts.strictNumbers), function () { return gen.assign(coerced, data); });
                var _a, _b;
            });
        }
        gen.if((_d = ["", " !== undefined"], _d.raw = ["", " !== undefined"], codegen_1._(_d, coerced)));
        for (var _i = 0; _i < coerceTo.length; _i++) {
            var t = coerceTo[_i];
            if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {
                coerceSpecificType(t);
            }
        }
        gen.else();
        reportTypeError(it);
        gen.endIf();
        gen.if((_e = ["", " !== undefined"], _e.raw = ["", " !== undefined"], codegen_1._(_e, coerced)), function () {
            gen.assign(data, coerced);
            assignParentData(it, coerced);
        });
        function coerceSpecificType(t) {
            switch (t) {
                case "string":
                    gen
                        .elseIf((_a = ["", " == \"number\" || ", " == \"boolean\""], _a.raw = ["", " == \"number\" || ", " == \"boolean\""], codegen_1._(_a, dataType, dataType)))
                        .assign(coerced, (_b = ["\"\" + ", ""], _b.raw = ["\"\" + ", ""], codegen_1._(_b, data)))
                        .elseIf((_c = ["", " === null"], _c.raw = ["", " === null"], codegen_1._(_c, data)))
                        .assign(coerced, (_d = ["\"\""], _d.raw = ["\"\""], codegen_1._(_d)));
                    return;
                case "number":
                    gen
                        .elseIf((_e = ["", " == \"boolean\" || ", " === null\n              || (", " == \"string\" && ", " && ", " == +", ")"], _e.raw = ["", " == \"boolean\" || ", " === null\n              || (", " == \"string\" && ", " && ", " == +", ")"], codegen_1._(_e, dataType, data, dataType, data, data, data)))
                        .assign(coerced, (_f = ["+", ""], _f.raw = ["+", ""], codegen_1._(_f, data)));
                    return;
                case "integer":
                    gen
                        .elseIf((_g = ["", " === \"boolean\" || ", " === null\n              || (", " === \"string\" && ", " && ", " == +", " && !(", " % 1))"], _g.raw = ["", " === \"boolean\" || ", " === null\n              || (", " === \"string\" && ", " && ", " == +", " && !(", " % 1))"], codegen_1._(_g, dataType, data, dataType, data, data, data, data)))
                        .assign(coerced, (_h = ["+", ""], _h.raw = ["+", ""], codegen_1._(_h, data)));
                    return;
                case "boolean":
                    gen
                        .elseIf((_j = ["", " === \"false\" || ", " === 0 || ", " === null"], _j.raw = ["", " === \"false\" || ", " === 0 || ", " === null"], codegen_1._(_j, data, data, data)))
                        .assign(coerced, false)
                        .elseIf((_k = ["", " === \"true\" || ", " === 1"], _k.raw = ["", " === \"true\" || ", " === 1"], codegen_1._(_k, data, data)))
                        .assign(coerced, true);
                    return;
                case "null":
                    gen.elseIf((_l = ["", " === \"\" || ", " === 0 || ", " === false"], _l.raw = ["", " === \"\" || ", " === 0 || ", " === false"], codegen_1._(_l, data, data, data)));
                    gen.assign(coerced, null);
                    return;
                case "array":
                    gen
                        .elseIf((_m = ["", " === \"string\" || ", " === \"number\"\n              || ", " === \"boolean\" || ", " === null"], _m.raw = ["", " === \"string\" || ", " === \"number\"\n              || ", " === \"boolean\" || ", " === null"], codegen_1._(_m, dataType, dataType, dataType, data)))
                        .assign(coerced, (_o = ["[", "]"], _o.raw = ["[", "]"], codegen_1._(_o, data)));
            }
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        }
        var _a, _b, _c, _d, _e;
    }
    function assignParentData(_a, expr) {
        var gen = _a.gen, parentData = _a.parentData, parentDataProperty = _a.parentDataProperty;
        // TODO use gen.property
        gen.if((_b = ["", " !== undefined"], _b.raw = ["", " !== undefined"], codegen_1._(_b, parentData)), function () {
            return gen.assign((_a = ["", "[", "]"], _a.raw = ["", "[", "]"], codegen_1._(_a, parentData, parentDataProperty)), expr);
            var _a;
        });
        var _b;
    }
    function checkDataType(dataType, data, strictNums, correct) {
        if (strictNums === void 0) { strictNums = "log"; }
        if (correct === void 0) { correct = DataType.Correct; }
        var EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
        var cond;
        switch (dataType) {
            case "null":
                return (_a = ["", " ", " null"], _a.raw = ["", " ", " null"], codegen_1._(_a, data, EQ));
            case "array":
                cond = (_b = ["Array.isArray(", ")"], _b.raw = ["Array.isArray(", ")"], codegen_1._(_b, data));
                break;
            case "object":
                cond = (_c = ["", " && typeof ", " == \"object\" && !Array.isArray(", ")"], _c.raw = ["", " && typeof ", " == \"object\" && !Array.isArray(", ")"], codegen_1._(_c, data, data, data));
                break;
            case "integer":
                cond = numCond((_d = ["!(", " % 1) && !isNaN(", ")"], _d.raw = ["!(", " % 1) && !isNaN(", ")"], codegen_1._(_d, data, data)));
                break;
            case "number":
                cond = numCond();
                break;
            default:
                return (_e = ["typeof ", " ", " ", ""], _e.raw = ["typeof ", " ", " ", ""], codegen_1._(_e, data, EQ, dataType));
        }
        return correct === DataType.Correct ? cond : codegen_1.not(cond);
        function numCond(_cond) {
            if (_cond === void 0) { _cond = codegen_1.nil; }
            return codegen_1.and((_a = ["typeof ", " == \"number\""], _a.raw = ["typeof ", " == \"number\""], codegen_1._(_a, data)), _cond, strictNums ? (_b = ["isFinite(", ")"], _b.raw = ["isFinite(", ")"], codegen_1._(_b, data)) : codegen_1.nil);
            var _a, _b;
        }
        var _a, _b, _c, _d, _e;
    }
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
        if (strictNums === void 0) { strictNums = "log"; }
        if (dataTypes.length === 1) {
            return checkDataType(dataTypes[0], data, strictNums, correct);
        }
        var cond;
        var types = util_1.toHash(dataTypes);
        if (types.array && types.object) {
            var notObj = (_a = ["typeof ", " != \"object\""], _a.raw = ["typeof ", " != \"object\""], codegen_1._(_a, data));
            cond = types.null ? notObj : (_b = ["!", " || ", ""], _b.raw = ["!", " || ", ""], codegen_1._(_b, data, notObj));
            delete types.null;
            delete types.array;
            delete types.object;
        }
        else {
            cond = codegen_1.nil;
        }
        if (types.number)
            delete types.integer;
        for (var t in types)
            cond = codegen_1.and(cond, checkDataType(t, as, JSONType, data, strictNums, correct));
        return cond;
        var _a, _b;
    }
    exports.checkDataTypes = checkDataTypes;
    "type", { type: string } >
    ;
    var typeError = {
        message: function (_a) {
            var schema = _a.schema;
            return ("must be " + schema);
        },
        params: function (_a) {
            var schema = _a.schema, schemaValue = _a.schemaValue;
            return typeof schema == "string" ? (_b = ["{type: ", "}"], _b.raw = ["{type: ", "}"], codegen_1._(_b, schema)) : (_c = ["{type: ", "}"], _c.raw = ["{type: ", "}"], codegen_1._(_c, schemaValue));
            var _b, _c;
        },
    };
    function reportTypeError(it) {
        var cxt = getTypeErrorContext(it);
        errors_1.reportError(cxt, typeError);
    }
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
        var gen = it.gen, data = it.data, schema = it.schema;
        var schemaCode = util_1.schemaRefOrVal(it, schema, "type");
        return {
            gen: gen,
            keyword: "type",
            data: data,
            schema: schema.type,
            schemaCode: schemaCode,
            schemaValue: schemaCode,
            parentSchema: schema,
            params: {},
            it: it,
        };
    }
});
