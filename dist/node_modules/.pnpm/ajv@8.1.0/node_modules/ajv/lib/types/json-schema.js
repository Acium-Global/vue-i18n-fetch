(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports"], function (require, exports) {
    true >
    ;
    true >>
        type;
    JSONType < T;
    string, _partial;
    boolean > ;
    _partial;
    true
        ? T | undefined
        : T;
    false > ;
    (
        |
            (_a = {
                    anyOf: readonly,
                    JSONSchemaType: function () { }
                },
                _a[] = ,
                _a
            )
        | (_b = {
                oneOf: readonly,
                JSONSchemaType: function () { }
            },
            _b[] = ,
            _b
        )
        | ((_c = {
                type: (T),
                extends: number
                    ? JSONType < "number" | "integer" : ,
                _partial:  >
                ,
                T: ,
                extends: string
                    ? JSONType < "string" : ,
                _partial:  >
                ,
                T: ,
                extends: boolean
                    ? JSONType < "boolean" : ,
                _partial:  >
                ,
                never: 
            },
            _c[] = ,
            _c
        ) & (T)));
    number
        ? NumberKeywords
        : T;
    string
        ? StringKeywords
        : T;
    boolean
        ? unknown
        : never;
    // this covers "normal" types; it's last so typescript looks to it first for errors
        | ((T));
    number
        ? {
            type: JSONType < "number" | "integer", _partial:  >
        } & NumberKeywords
        : T;
    string
        ? {
            type: JSONType < "string", _partial:  >
        } & StringKeywords
        : T;
    boolean
        ? {
            type: "boolean"
        }
        : T;
    [any].concat(any[])
        ? {
            // JSON AnySchema for tuple
            type: JSONType < "array", _partial:  >
                items } : {
        readonly: [K in keyof, T] -  ?  : JSONSchemaType( & Nullable())
    } & { length: T["length"] };
    minItems: T["length"];
     & ({ maxItems: T["length"] } | { additionalItems: false });
    T;
    readonly;
    any[]
        ? (_d = {
                type: JSONType < "array",
                _partial:  >
                    items,
                JSONSchemaType: function () { }
            },
            _d[0] =  >
                contains ?  : PartialSchema < T[0] >
                minItems ?  : number,
            _d.maxItems = number,
            _d.minContains = number,
            _d.maxContains = number,
            _d.uniqueItems = true,
            _d.additionalItems = never,
            _d
        )
        : T;
    Record({
        // JSON AnySchema for records and dictionaries
        // "required" is not optional because it is often forgotten
        // "properties" are optional for more concise dictionary schemas
        // "patternProperties" and can be only used with interfaces that have string index
        type: JSONType < "object", _partial:  >
            // "required" type does not guarantee that all required properties are listed
            // it only asserts that optional cannot be listed
            required, _partial: , extends: true ? Readonly(Readonly < RequiredMembers < T > [] >
            additionalProperties ?  : boolean | JSONSchemaType < T[string] >
            unevaluatedProperties ?  : boolean | JSONSchemaType < T[string] >
            properties ?  : _partial) : , extends: true ? Partial(PropertiesSchema < T >
            patternProperties ?  : (_e = {}, _e[Pattern in string] = JSONSchemaType(), _e), propertyNames ?  : JSONSchemaType < string >
            dependencies ?  : (_f = {}, _f[K in keyof] = T, _f.Readonly = , _f[] =  >  | PartialSchema(), _f), dependentRequired ?  : (_g = {}, _g[K in keyof] = T, _g.Readonly = , _g[] =  > , _g), dependentSchemas ?  : (_h = {}, _h[K in keyof] = T, _h.PartialSchema = , _h), minProperties ?  : number, maxProperties ?  : number)
            :
    }, T, null
        ? {
            nullable: true
        }
        : never) & {
        allOf: Readonly < PartialSchema < T > [] >
            anyOf ?  : Readonly < PartialSchema < T > [] >
            oneOf ?  : Readonly < PartialSchema < T > [] >
        ,
        if: PartialSchema < T >
            then ?  : PartialSchema < T >
        ,
        else: PartialSchema < T >
            not ?  : PartialSchema()
    };
     & (_j = {},
        _j[keyword] = string,
        _j.any = $id ?  : string,
        _j.$ref = string,
        _j.$defs = (_k = {},
            _k[Key in string] = JSONSchemaType < Known,
            _k.true =  >
            ,
            _k
        ),
        _j.definitions = (_l = {},
            _l[Key in string] = JSONSchemaType < Known,
            _l.true =  >
            ,
            _l
        ),
        _j
    );
    null;
    T;
    - ?  : (JSONSchemaType( & Nullable() | { $ref: string }));
    T;
    - ?  : undefined;
    T[K] ? never : K;
    [keyof, T];
    T
        ? {
            nullable: true,
            const: never // any non-null value would fail `const: null`, `null` would fail any other value in const
            ,
            enum: Readonly < (T | null)[] >
             // `null` must be explicitly included in "enum" for `null` to pass
            ,
            default: T | null
        }
        : {
            const: T,
            enum: Readonly < T[] >
            ,
            default: T
        };
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
});
