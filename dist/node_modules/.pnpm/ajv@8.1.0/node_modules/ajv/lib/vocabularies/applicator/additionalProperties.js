(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "../code", "../../compile/codegen", "../../compile/names", "../../compile/util"], function (require, exports) {
    {
        CodeKeywordDefinition,
            AddedKeywordDefinition,
            ErrorObject,
            KeywordErrorDefinition,
            AnySchema,
        ;
    }
    from;
    "../../types";
    var code_1 = require("../code");
    var codegen_1 = require("../../compile/codegen");
    var names_1 = require("../../compile/names");
    {
        SubschemaArgs;
    }
    from;
    "../../compile/validate/subschema";
    var util_1 = require("../../compile/util");
    "additionalProperties",
        { additionalProperty: string },
        AnySchema
            >
    ;
    var error = {
        message: "must NOT have additional properties",
        params: function (_a) {
            var params = _a.params;
            return (_b = ["{additionalProperty: ", "}"], _b.raw = ["{additionalProperty: ", "}"], codegen_1._(_b, params.additionalProperty));
            var _b;
        },
    };
    var def =  & AddedKeywordDefinition, _a = void 0, _b = _a.keyword,  = _b === void 0 ? "additionalProperties" : _b, _c = _a.type, _d = _c === void 0 ? "object" : _c, _e = _a.schemaType, _f = _e === void 0 ? "boolean" : _e,  = _a["object"], _g = _a.allowUndefined,  = _g === void 0 ? true : _g, _h = _a.trackErrors,  = _h === void 0 ? true : _h, error = _a.error, _j = _a.code, code = _j === void 0 ? function (cxt) {
        var gen = cxt.gen, schema = cxt.schema, parentSchema = cxt.parentSchema, data = cxt.data, errsCount = cxt.errsCount, it = cxt.it;
        /* istanbul ignore if */
        if (!errsCount)
            throw new Error("ajv implementation error");
        var allErrors = it.allErrors, opts = it.opts;
        it.props = true;
        if (opts.removeAdditional !== "all" && util_1.alwaysValidSchema(it, schema))
            return;
        var props = code_1.allSchemaProperties(parentSchema.properties);
        var patProps = code_1.allSchemaProperties(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((_a = ["", " === ", ""], _a.raw = ["", " === ", ""], codegen_1._(_a, errsCount, names_1.default.errors)));
        function checkAdditionalProperties() {
            gen.forIn("key", data, function (key) {
                if (!props.length && !patProps.length)
                    additionalPropertyCode(key);
                else
                    gen.if(isAdditional(key), function () { return additionalPropertyCode(key); });
            });
        }
        function isAdditional(key) {
            var definedProp;
            if (props.length > 8) {
                // TODO maybe an option instead of hard-coded 8?
                var propsSchema = util_1.schemaRefOrVal(it, parentSchema.properties, "properties");
                definedProp = code_1.isOwnProperty(gen, propsSchema, as, codegen_1.Code, key);
            }
            else if (props.length) {
                definedProp = codegen_1.or.apply(void 0, props.map(function (p) { return (_a = ["", " === ", ""], _a.raw = ["", " === ", ""], codegen_1._(_a, key, p)); var _a; }));
            }
            else {
                definedProp = codegen_1.nil;
            }
            if (patProps.length) {
                definedProp = codegen_1.or.apply(void 0, [definedProp].concat(patProps.map(function (p) { return (_a = ["", ".test(", ")"], _a.raw = ["", ".test(", ")"], codegen_1._(_a, code_1.usePattern(cxt, p), key)); var _a; })));
            }
            return codegen_1.not(definedProp);
        }
        function deleteAdditional(key) {
            gen.code((_a = ["delete ", "[", "]"], _a.raw = ["delete ", "[", "]"], codegen_1._(_a, data, key)));
            var _a;
        }
        function additionalPropertyCode(key) {
            if (opts.removeAdditional === "all" || (opts.removeAdditional && schema === false)) {
                deleteAdditional(key);
                return;
            }
            if (schema === false) {
                cxt.setParams({ additionalProperty: key });
                cxt.error();
                if (!allErrors)
                    gen.break();
                return;
            }
            if (typeof schema == "object" && !util_1.alwaysValidSchema(it, schema)) {
                var valid = gen.name("valid");
                if (opts.removeAdditional === "failing") {
                    applyAdditionalSchema(key, valid, false);
                    gen.if(codegen_1.not(valid), function () {
                        cxt.reset();
                        deleteAdditional(key);
                    });
                }
                else {
                    applyAdditionalSchema(key, valid);
                    if (!allErrors)
                        gen.if(codegen_1.not(valid), function () { return gen.break(); });
                }
            }
        }
        function applyAdditionalSchema(key, valid, errors) {
            if (errors === void 0) { errors = false; }
            var subschema = {
                keyword: "additionalProperties",
                dataProp: key,
                dataPropType: util_1.Type.Str,
            };
            if (errors === false) {
                Object.assign(subschema, {
                    compositeRule: true,
                    createErrors: false,
                    allErrors: false,
                });
            }
            cxt.subschema(subschema, valid);
        }
        var _a;
    } : _j;
    exports.default = def;
});
