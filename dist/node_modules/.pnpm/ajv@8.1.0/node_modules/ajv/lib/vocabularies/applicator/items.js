(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "../../compile/codegen", "../../compile/util", "../code"], function (require, exports) {
    {
        CodeKeywordDefinition, AnySchema, AnySchemaObject;
    }
    from;
    "../../types";
    {
        KeywordCxt;
    }
    from;
    "../../compile/validate";
    var codegen_1 = require("../../compile/codegen");
    var util_1 = require("../../compile/util");
    var code_1 = require("../code");
    var def = {
        keyword: "items",
        type: "array",
        schemaType: ["object", "array", "boolean"],
        before: "uniqueItems",
        code: function (cxt) {
            var schema = cxt.schema, it = cxt.it;
            if (Array.isArray(schema))
                return validateTuple(cxt, "additionalItems", schema);
            it.items = true;
            if (util_1.alwaysValidSchema(it, schema))
                return;
            cxt.ok(code_1.validateArray(cxt));
        },
    };
    function validateTuple(cxt, extraItems, schArr) {
        if (schArr === void 0) { schArr = cxt.schema; }
        var gen = cxt.gen, parentSchema = cxt.parentSchema, data = cxt.data, keyword = cxt.keyword, it = cxt.it;
        checkStrictTuple(parentSchema);
        if (it.opts.unevaluated && schArr.length && it.items !== true) {
            it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
        }
        var valid = gen.name("valid");
        var len = gen.const("len", (_a = ["", ".length"], _a.raw = ["", ".length"], codegen_1._(_a, data)));
        schArr.forEach(function (sch, i) {
            if (util_1.alwaysValidSchema(it, sch))
                return;
            gen.if((_a = ["", " > ", ""], _a.raw = ["", " > ", ""], codegen_1._(_a, len, i)), function () {
                return cxt.subschema({
                    keyword: keyword,
                    schemaProp: i,
                    dataProp: i,
                }, valid);
            });
            cxt.ok(valid);
            var _a;
        });
        function checkStrictTuple(sch) {
            var opts = it.opts, errSchemaPath = it.errSchemaPath;
            var l = schArr.length;
            var fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
            if (opts.strictTuples && !fullTuple) {
                var msg = "\"" + keyword + "\" is " + l + "-tuple, but minItems or maxItems/" + extraItems + " are not specified or different at path \"" + errSchemaPath + "\"";
                util_1.checkStrictMode(it, msg, opts.strictTuples);
            }
        }
        var _a;
    }
    exports.validateTuple = validateTuple;
    exports.default = def;
});
