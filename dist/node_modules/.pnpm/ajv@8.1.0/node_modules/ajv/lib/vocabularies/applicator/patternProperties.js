(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "../code", "../../compile/codegen", "../../compile/util", "../../compile/util"], function (require, exports) {
    {
        CodeKeywordDefinition;
    }
    from;
    "../../types";
    {
        KeywordCxt;
    }
    from;
    "../../compile/validate";
    var code_1 = require("../code");
    var codegen_1 = require("../../compile/codegen");
    var util_1 = require("../../compile/util");
    var util_2 = require("../../compile/util");
    var def = {
        keyword: "patternProperties",
        type: "object",
        schemaType: "object",
        code: function (cxt) {
            var gen = cxt.gen, schema = cxt.schema, data = cxt.data, parentSchema = cxt.parentSchema, it = cxt.it;
            var opts = it.opts;
            var patterns = code_1.schemaProperties(it, schema);
            // TODO mark properties matching patterns with always valid schemas as evaluated
            if (patterns.length === 0)
                return;
            var checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
            var valid = gen.name("valid");
            if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
                it.props = util_2.evaluatedPropsToName(gen, it.props);
            }
            var props = it.props;
            validatePatternProperties();
            function validatePatternProperties() {
                for (var _i = 0; _i < patterns.length; _i++) {
                    var pat = patterns[_i];
                    if (checkProperties)
                        checkMatchingProperties(pat);
                    if (it.allErrors) {
                        validateProperties(pat);
                    }
                    else {
                        gen.var(valid, true); // TODO var
                        validateProperties(pat);
                        gen.if(valid);
                    }
                }
            }
            function checkMatchingProperties(pat) {
                for (var prop in checkProperties) {
                    if (new RegExp(pat).test(prop)) {
                        util_1.checkStrictMode(it, "property " + prop + " matches pattern " + pat + " (use allowMatchingProperties)");
                    }
                }
            }
            function validateProperties(pat) {
                gen.forIn("key", data, function (key) {
                    gen.if((_a = ["", ".test(", ")"], _a.raw = ["", ".test(", ")"], codegen_1._(_a, code_1.usePattern(cxt, pat), key)), function () {
                        cxt.subschema({
                            keyword: "patternProperties",
                            schemaProp: pat,
                            dataProp: key,
                            dataPropType: util_2.Type.Str,
                        }, valid);
                        if (it.opts.unevaluated && props !== true) {
                            gen.assign((_a = ["", "[", "]"], _a.raw = ["", "[", "]"], codegen_1._(_a, props, key)), true);
                        }
                        else if (!it.allErrors) {
                            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
                            // or if all properties were evaluated (props === true)
                            gen.if(codegen_1.not(valid), function () { return gen.break(); });
                        }
                        var _a;
                    });
                    var _a;
                });
            }
        },
    };
    exports.default = def;
});
