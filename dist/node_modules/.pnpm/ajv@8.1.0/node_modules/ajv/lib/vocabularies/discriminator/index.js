(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "../../compile/codegen", "../discriminator/types"], function (require, exports) {
    {
        CodeKeywordDefinition, AnySchemaObject, KeywordErrorDefinition;
    }
    from;
    "../../types";
    {
        KeywordCxt;
    }
    from;
    "../../compile/validate";
    var codegen_1 = require("../../compile/codegen");
    var types_1 = require("../discriminator/types");
    var error = {
        message: function (_a) {
            var _b = _a.params, discrError = _b.discrError, tagName = _b.tagName;
            return discrError === types_1.DiscrError.Tag
                ? "tag \"" + tagName + "\" must be string"
                : "value of tag \"" + tagName + "\" must be in oneOf";
        },
        params: function (_a) {
            var _b = _a.params, discrError = _b.discrError, tag = _b.tag, tagName = _b.tagName;
            return (_c = ["{error: ", ", tag: ", ", tagValue: ", "}"], _c.raw = ["{error: ", ", tag: ", ", tagValue: ", "}"], codegen_1._(_c, discrError, tagName, tag));
            var _c;
        },
    };
    var def = {
        keyword: "discriminator",
        type: "object",
        schemaType: "object",
        error: error,
        code: function (cxt) {
            var gen = cxt.gen, data = cxt.data, schema = cxt.schema, parentSchema = cxt.parentSchema, it = cxt.it;
            var oneOf = parentSchema.oneOf;
            if (!it.opts.discriminator) {
                throw new Error("discriminator: requires discriminator option");
            }
            var tagName = schema.propertyName;
            if (typeof tagName != "string")
                throw new Error("discriminator: requires propertyName");
            if (schema.mapping)
                throw new Error("discriminator: mapping is not supported");
            if (!oneOf)
                throw new Error("discriminator: requires oneOf keyword");
            var valid = gen.let("valid", false);
            var tag = gen.const("tag", (_a = ["", "", ""], _a.raw = ["", "", ""], codegen_1._(_a, data, codegen_1.getProperty(tagName))));
            gen.if((_b = ["typeof ", " == \"string\""], _b.raw = ["typeof ", " == \"string\""], codegen_1._(_b, tag)), function () { return validateMapping(); }, function () { return cxt.error(false, { discrError: types_1.DiscrError.Tag, tag: tag, tagName: tagName }); });
            cxt.ok(valid);
            function validateMapping() {
                var mapping = getMapping();
                gen.if(false);
                for (var tagValue in mapping) {
                    gen.elseIf((_a = ["", " === ", ""], _a.raw = ["", " === ", ""], codegen_1._(_a, tag, tagValue)));
                    gen.assign(valid, applyTagSchema(mapping[tagValue]));
                }
                gen.else();
                cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag: tag, tagName: tagName });
                gen.endIf();
                var _a;
            }
            function applyTagSchema(schemaProp) {
                var _valid = gen.name("valid");
                var schCxt = cxt.subschema({ keyword: "oneOf", schemaProp: schemaProp }, _valid);
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
                return _valid;
            }
            function getMapping() {
                var oneOfMapping = {};
                var topRequired = hasRequired(parentSchema);
                var tagRequired = true;
                for (var i = 0; i < oneOf.length; i++) {
                    var sch = oneOf[i];
                    var propSch = sch.properties ? .[tagName]
                        :
                    ;
                    if (typeof propSch != "object") {
                        throw new Error("discriminator: oneOf schemas must have \"properties/" + tagName + "\"");
                    }
                    tagRequired = tagRequired && (topRequired || hasRequired(sch));
                    addMappings(propSch, i);
                }
                if (!tagRequired)
                    throw new Error("discriminator: \"" + tagName + "\" must be required");
                return oneOfMapping;
                function hasRequired(_a) {
                    var required = _a.required;
                    return Array.isArray(required) && required.includes(tagName);
                }
                function addMappings(sch, i) {
                    if (sch.const) {
                        addMapping(sch.const, i);
                    }
                    else if (sch.enum) {
                        for (var _i = 0, _a = sch.enum; _i < _a.length; _i++) {
                            var tagValue = _a[_i];
                            addMapping(tagValue, i);
                        }
                    }
                    else {
                        throw new Error("discriminator: \"properties/" + tagName + "\" must have \"const\" or \"enum\"");
                    }
                }
                function addMapping(tagValue, i) {
                    if (typeof tagValue != "string" || tagValue in oneOfMapping) {
                        throw new Error("discriminator: \"" + tagName + "\" values must be unique strings");
                    }
                    oneOfMapping[tagValue] = i;
                }
            }
            var _a, _b;
        },
    };
    exports.default = def;
});
