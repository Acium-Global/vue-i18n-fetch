(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "../code", "../../compile/util", "../../compile/codegen", "./metadata", "./nullable", "./error"], function (require, exports) {
    {
        CodeKeywordDefinition,
            ErrorObject,
            KeywordErrorDefinition,
            SchemaObject,
        ;
    }
    from;
    "../../types";
    {
        KeywordCxt;
    }
    from;
    "../../compile/validate";
    var code_1 = require("../code");
    var util_1 = require("../../compile/util");
    var codegen_1 = require("../../compile/codegen");
    var metadata_1 = require("./metadata");
    var nullable_1 = require("./nullable");
    var error_1 = require("./error");
    var PropError;
    (function (PropError) {
        PropError[PropError["Additional"] = "additional"] = "Additional";
        PropError[PropError["Missing"] = "missing"] = "Missing";
    })(PropError || (PropError = {}));
    "properties" | "optionalProperties";
    "object", PropSchema >
        | ErrorObject(
            | ErrorObject < PropKeyword, { error: PropError.Missing, missingProperty: string }, PropSchema >
        );
    exports.error = {
        message: function (cxt) {
            var params = cxt.params;
            return params.propError
                ? params.propError === PropError.Additional
                    ? "must NOT have additional properties"
                    : "must have property '" + params.missingProperty + "'"
                : error_1.typeErrorMessage(cxt, "object");
        },
        params: function (cxt) {
            var params = cxt.params;
            return params.propError
                ? params.propError === PropError.Additional
                    ? (_a = ["{error: ", ", additionalProperty: ", "}"], _a.raw = ["{error: ", ", additionalProperty: ", "}"], codegen_1._(_a, params.propError, params.additionalProperty))
                    : (_b = ["{error: ", ", missingProperty: ", "}"], _b.raw = ["{error: ", ", missingProperty: ", "}"], codegen_1._(_b, params.propError, params.missingProperty))
                : error_1.typeErrorParams(cxt, "object");
            var _a, _b;
        },
    };
    var def = {
        keyword: "properties",
        schemaType: "object",
        error: exports.error,
        code: validateProperties,
    };
    // const error: KeywordErrorDefinition = {
    //   message: "should NOT have additional properties",
    //   params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,
    // }
    function validateProperties(cxt) {
        metadata_1.checkMetadata(cxt);
        var gen = cxt.gen, data = cxt.data, parentSchema = cxt.parentSchema, it = cxt.it;
        var additionalProperties = parentSchema.additionalProperties, nullable = parentSchema.nullable;
        if (it.jtdDiscriminator && nullable)
            throw new Error("JTD: nullable inside discriminator mapping");
        if (commonProperties()) {
            throw new Error("JTD: properties and optionalProperties have common members");
        }
        var _a = schemaProperties("properties"), allProps = _a[0], properties = _a[1];
        var _b = schemaProperties("optionalProperties"), allOptProps = _b[0], optProperties = _b[1];
        if (properties.length === 0 && optProperties.length === 0 && additionalProperties) {
            return;
        }
        var _c = it.jtdDiscriminator === undefined
            ? nullable_1.checkNullableObject(cxt, data)
            : [gen.let("valid", false), true], valid = _c[0], cond = _c[1];
        gen.if(cond, function () {
            return gen.assign(valid, true).block(function () {
                validateProps(properties, "properties", true);
                validateProps(optProperties, "optionalProperties");
                if (!additionalProperties)
                    validateAdditional();
            });
        });
        cxt.pass(valid);
        function commonProperties() {
            var props = parentSchema.properties, as = Record( | undefined);
            var optProps = parentSchema.optionalProperties, as = Record( | undefined);
            if (!(props && optProps))
                return false;
            for (var p in props) {
                if (Object.prototype.hasOwnProperty.call(optProps, p))
                    return true;
            }
            return false;
        }
        function schemaProperties(keyword) {
            var schema = parentSchema[keyword];
            var allPs = schema ? code_1.allSchemaProperties(schema) : [];
            if (it.jtdDiscriminator && allPs.some(function (p) { return p === it.jtdDiscriminator; })) {
                throw new Error("JTD: discriminator tag used in " + keyword);
            }
            var ps = allPs.filter(function (p) { return !util_1.alwaysValidSchema(it, schema[p]); });
            return [allPs, ps];
        }
        function validateProps(props, keyword, required) {
            var _valid = gen.var("valid");
            for (var _i = 0; _i < props.length; _i++) {
                var prop = props[_i];
                gen.if(code_1.propertyInData(gen, data, prop, it.opts.ownProperties), function () { return applyPropertySchema(prop, keyword, _valid); }, function () { return missingProperty(prop); });
                cxt.ok(_valid);
            }
            function missingProperty(prop) {
                if (required) {
                    gen.assign(_valid, false);
                    cxt.error(false, { propError: PropError.Missing, missingProperty: prop }, { schemaPath: prop });
                }
                else {
                    gen.assign(_valid, true);
                }
            }
        }
        function applyPropertySchema(prop, keyword, _valid) {
            cxt.subschema({
                keyword: keyword,
                schemaProp: prop,
                dataProp: prop,
            }, _valid);
        }
        function validateAdditional() {
            gen.forIn("key", data, function (key) {
                var _allProps = it.jtdDiscriminator === undefined ? allProps : [it.jtdDiscriminator].concat(allProps);
                var addProp = isAdditional(key, _allProps, "properties");
                var addOptProp = isAdditional(key, allOptProps, "optionalProperties");
                var extra = addProp === true ? addOptProp : addOptProp === true ? addProp : codegen_1.and(addProp, addOptProp);
                gen.if(extra, function () {
                    if (it.opts.removeAdditional) {
                        gen.code((_a = ["delete ", "[", "]"], _a.raw = ["delete ", "[", "]"], codegen_1._(_a, data, key)));
                    }
                    else {
                        cxt.error(false, { propError: PropError.Additional, additionalProperty: key }, { instancePath: key, parentSchema: true });
                        if (!it.opts.allErrors)
                            gen.break();
                    }
                    var _a;
                });
            });
        }
        true;
        {
            var additional;
            if (props.length > 8) {
                // TODO maybe an option instead of hard-coded 8?
                var propsSchema = util_1.schemaRefOrVal(it, parentSchema[keyword], keyword);
                additional = codegen_1.not(code_1.isOwnProperty(gen, propsSchema, as, codegen_1.Code, key));
            }
            else if (props.length) {
                additional = codegen_1.and.apply(void 0, props.map(function (p) { return (_a = ["", " !== ", ""], _a.raw = ["", " !== ", ""], codegen_1._(_a, key, p)); var _a; }));
            }
            else {
                additional = true;
            }
            return additional;
        }
    }
    exports.validateProperties = validateProperties;
    exports.default = def;
});
