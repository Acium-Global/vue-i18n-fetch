(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "../../compile", "../../compile/codegen", "../../compile/ref_error", "../../compile/names", "../core/ref", "./metadata"], function (require, exports) {
    {
        CodeKeywordDefinition, AnySchemaObject;
    }
    from;
    "../../types";
    {
        KeywordCxt;
    }
    from;
    "../../compile/validate";
    var compile_1 = require("../../compile");
    var codegen_1 = require("../../compile/codegen");
    var ref_error_1 = require("../../compile/ref_error");
    var names_1 = require("../../compile/names");
    var ref_1 = require("../core/ref");
    var metadata_1 = require("./metadata");
    var def = {
        keyword: "ref",
        schemaType: "string",
        code: function (cxt) {
            metadata_1.checkMetadata(cxt);
            var gen = cxt.gen, data = cxt.data, ref = cxt.schema, parentSchema = cxt.parentSchema, it = cxt.it;
            var root = it.schemaEnv.root;
            var valid = gen.name("valid");
            if (parentSchema.nullable) {
                gen.var(valid, (_a = ["", " === null"], _a.raw = ["", " === null"], codegen_1._(_a, data)));
                gen.if(codegen_1.not(valid), validateJtdRef);
            }
            else {
                gen.var(valid, false);
                validateJtdRef();
            }
            cxt.ok(valid);
            function validateJtdRef() {
                var refSchema = (root.schema), as = AnySchemaObject, definitions, ref = (void 0)[0];
                if (!refSchema)
                    throw new ref_error_1.default("", ref, "No definition " + ref);
                if (hasRef(refSchema) || !it.opts.inlineRefs)
                    callValidate(refSchema);
                else
                    inlineRefSchema(refSchema);
            }
            function callValidate(schema) {
                var sch = compile_1.compileSchema.call(it.self, new compile_1.SchemaEnv({ schema: schema, root: root, schemaPath: "/definitions/" + ref }));
                var v = ref_1.getValidate(cxt, sch);
                var errsCount = gen.const("_errs", names_1.default.errors);
                ref_1.callRef(cxt, v, sch, sch.$async);
                gen.assign(valid, (_a = ["", " === ", ""], _a.raw = ["", " === ", ""], codegen_1._(_a, errsCount, names_1.default.errors)));
                var _a;
            }
            function inlineRefSchema(schema) {
                var schName = gen.scopeValue("schema", it.opts.code.source === true ? { ref: schema, code: codegen_1.stringify(schema) } : { ref: schema });
                cxt.subschema({
                    schema: schema,
                    dataTypes: [],
                    schemaPath: codegen_1.nil,
                    topSchemaRef: schName,
                    errSchemaPath: "/definitions/" + ref,
                }, valid);
            }
            var _a;
        },
    };
    function hasRef(schema) {
        for (var key in schema) {
            var sch = void 0;
            if (key === "ref" || (typeof (sch = schema[key]) == "object" && hasRef(sch)))
                return true;
        }
        return false;
    }
    exports.hasRef = hasRef;
    exports.default = def;
});
