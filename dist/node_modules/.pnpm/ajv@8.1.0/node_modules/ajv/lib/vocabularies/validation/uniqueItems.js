(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "../../compile/validate/dataType", "../../compile/codegen", "../../compile/util", "../../runtime/equal"], function (require, exports) {
    {
        CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition;
    }
    from;
    "../../types";
    {
        KeywordCxt;
    }
    from;
    "../../compile/validate";
    var dataType_1 = require("../../compile/validate/dataType");
    var codegen_1 = require("../../compile/codegen");
    var util_1 = require("../../compile/util");
    var equal_1 = require("../../runtime/equal");
    "uniqueItems",
        { i: number, j: number },
        boolean | { $data: string }
            >
    ;
    var error = {
        message: function (_a) {
            var _b = _a.params, i = _b.i, j = _b.j;
            return (_c = ["must NOT have duplicate items (items ## ", " and ", " are identical)"], _c.raw = ["must NOT have duplicate items (items ## ", " and ", " are identical)"], codegen_1.str(_c, j, i));
            var _c;
        },
        params: function (_a) {
            var _b = _a.params, i = _b.i, j = _b.j;
            return (_c = ["{i: ", ", j: ", "}"], _c.raw = ["{i: ", ", j: ", "}"], codegen_1._(_c, i, j));
            var _c;
        },
    };
    var def = {
        keyword: "uniqueItems",
        type: "array",
        schemaType: "boolean",
        $data: true,
        error: error,
        code: function (cxt) {
            var gen = cxt.gen, data = cxt.data, $data = cxt.$data, schema = cxt.schema, parentSchema = cxt.parentSchema, schemaCode = cxt.schemaCode, it = cxt.it;
            if (!$data && !schema)
                return;
            var valid = gen.let("valid");
            var itemTypes = parentSchema.items ? dataType_1.getSchemaTypes(parentSchema.items) : [];
            cxt.block$data(valid, validateUniqueItems, (_a = ["", " === false"], _a.raw = ["", " === false"], codegen_1._(_a, schemaCode)));
            cxt.ok(valid);
            function validateUniqueItems() {
                var i = gen.let("i", (_a = ["", ".length"], _a.raw = ["", ".length"], codegen_1._(_a, data)));
                var j = gen.let("j");
                cxt.setParams({ i: i, j: j });
                gen.assign(valid, true);
                gen.if((_b = ["", " > 1"], _b.raw = ["", " > 1"], codegen_1._(_b, i)), function () { return (canOptimize() ? loopN : loopN2)(i, j); });
                var _a, _b;
            }
            function canOptimize() {
                return itemTypes.length > 0 && !itemTypes.some(function (t) { return t === "object" || t === "array"; });
            }
            function loopN(i, j) {
                var item = gen.name("item");
                var wrongType = dataType_1.checkDataTypes(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
                var indices = gen.const("indices", (_a = ["{}"], _a.raw = ["{}"], codegen_1._(_a)));
                gen.for((_b = [";", "--;"], _b.raw = [";", "--;"], codegen_1._(_b, i)), function () {
                    gen.let(item, (_a = ["", "[", "]"], _a.raw = ["", "[", "]"], codegen_1._(_a, data, i)));
                    gen.if(wrongType, (_b = ["continue"], _b.raw = ["continue"], codegen_1._(_b)));
                    if (itemTypes.length > 1)
                        gen.if((_c = ["typeof ", " == \"string\""], _c.raw = ["typeof ", " == \"string\""], codegen_1._(_c, item)), (_d = ["", " += \"_\""], _d.raw = ["", " += \"_\""], codegen_1._(_d, item)));
                    gen
                        .if((_e = ["typeof ", "[", "] == \"number\""], _e.raw = ["typeof ", "[", "] == \"number\""], codegen_1._(_e, indices, item)), function () {
                        gen.assign(j, (_a = ["", "[", "]"], _a.raw = ["", "[", "]"], codegen_1._(_a, indices, item)));
                        cxt.error();
                        gen.assign(valid, false).break();
                        var _a;
                    })
                        .code((_f = ["", "[", "] = ", ""], _f.raw = ["", "[", "] = ", ""], codegen_1._(_f, indices, item, i)));
                    var _a, _b, _c, _d, _e, _f;
                });
                var _a, _b;
            }
            function loopN2(i, j) {
                var eql = util_1.useFunc(gen, equal_1.default);
                var outer = gen.name("outer");
                gen.label(outer).for((_a = [";", "--;"], _a.raw = [";", "--;"], codegen_1._(_a, i)), function () {
                    return gen.for((_a = ["", " = ", "; ", "--;"], _a.raw = ["", " = ", "; ", "--;"], codegen_1._(_a, j, i, j)), function () {
                        return gen.if((_a = ["", "(", "[", "], ", "[", "])"], _a.raw = ["", "(", "[", "], ", "[", "])"], codegen_1._(_a, eql, data, i, data, j)), function () {
                            cxt.error();
                            gen.assign(valid, false).break(outer);
                        });
                        var _a;
                    });
                    var _a;
                });
                var _a;
            }
            var _a;
        },
    };
    exports.default = def;
});
