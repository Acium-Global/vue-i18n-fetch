(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "./codegen", "../runtime/validation_error", "./names", "./resolve", "./util", "./validate", "uri-js"], function (require, exports) {
    {
        AnySchema,
            AnySchemaObject,
            AnyValidateFunction,
            AsyncValidateFunction,
            EvaluatedProperties,
            EvaluatedItems,
        ;
    }
    from;
    "../types";
    from;
    "../core";
    {
        InstanceOptions;
    }
    from;
    "../core";
    var codegen_1 = require("./codegen");
    var validation_error_1 = require("../runtime/validation_error");
    var names_1 = require("./names");
    var resolve_1 = require("./resolve");
    var util_1 = require("./util");
    var validate_1 = require("./validate");
    var URI = require("uri-js");
    readonly;
    gen: codegen_1.CodeGen;
    readonly;
    allErrors ?  : boolean; // validation mode - whether to collect all errors or break on error
    readonly;
    data: codegen_1.Name; // Name with reference to the current part of data instance
    readonly;
    parentData: codegen_1.Name; // should be used in keywords modifying data
    readonly;
    parentDataProperty: codegen_1.Code | number; // should be used in keywords modifying data
    readonly;
    dataNames: codegen_1.Name[];
    readonly;
    dataPathArr: (codegen_1.Code | number)[];
    readonly;
    dataLevel: number; // the level of the currently validated data,
    // it can be used to access both the property names and the data on all levels from the top.
    dataTypes: JSONType[]; // data types applied to the current part of data instance
    definedProperties: Set < string >
        readonly;
    topSchemaRef: codegen_1.Code;
    readonly;
    validateName: codegen_1.Name;
    evaluated ?  : codegen_1.Name;
    readonly;
    validation_error_1.default ?  : codegen_1.Name;
    readonly;
    schema: AnySchema; // current schema object - equal to parentSchema passed via KeywordCxt
    readonly;
    schemaEnv: SchemaEnv;
    readonly;
    rootId: string;
    baseId: string; // the current schema base URI that should be used as the base for resolving URIs in references (\$ref)
    readonly;
    schemaPath: codegen_1.Code; // the run-time expression that evaluates to the property name of the current schema
    readonly;
    errSchemaPath: string; // this is actual string, should not be changed to Code
    readonly;
    errorPath: codegen_1.Code;
    readonly;
    propertyName ?  : codegen_1.Name;
    readonly;
    compositeRule ?  : boolean; // true indicates that the current schema is inside the compound keyword,
    // where failing some rule doesn't mean validation failure (`anyOf`, `oneOf`, `not`, `if`).
    // This flag is used to determine whether you can return validation result immediately after any error in case the option `allErrors` is not `true.
    // You only need to use it if you have many steps in your keywords and potentially can define multiple errors.
    props ?  : EvaluatedProperties | codegen_1.Name; // properties evaluated by this schema - used by parent schema or assigned to validation function
    items ?  : EvaluatedItems | codegen_1.Name; // last item evaluated by this schema - used by parent schema or assigned to validation function
    jtdDiscriminator ?  : string;
    jtdMetadata ?  : boolean;
    readonly;
    createErrors ?  : boolean;
    readonly;
    opts: InstanceOptions; // Ajv instance option.
    readonly;
    self: Ajv; // current Ajv instance
    readonly;
    schema: AnySchemaObject;
    readonly;
    schema: AnySchema;
    readonly;
    root ?  : SchemaEnv;
    readonly;
    baseId ?  : string;
    readonly;
    schemaPath ?  : string;
    readonly;
    localRefs ?  : LocalRefs;
    readonly;
    meta ?  : boolean;
    var SchemaEnv = (function () {
        function SchemaEnv() {
            this.readonly = schema;
            this.readonly = root;
            this.readonly = meta ?  : boolean;
            this.readonly = $async ?  : boolean; // true if the current schema is asynchronous.
            this.readonly = refs;
            this.SchemaRefs = {};
            this.readonly = dynamicAnchors;
        }
        return SchemaEnv;
    })();
    exports.SchemaEnv = SchemaEnv;
    {
        [Ref in string] ?  : true;
    }
    { }
    validate ?  : AnyValidateFunction;
    validateName ?  : codegen_1.ValueScopeName;
    serialize ?  : function (data) { return string; };
    serializeName ?  : codegen_1.ValueScopeName;
    parse ?  : function (data) { return unknown; };
    parseName ?  : codegen_1.ValueScopeName;
    constructor(env, SchemaEnvArgs);
    {
        var schema;
        if (typeof env.schema == "object")
            schema = env.schema;
        this.schema = env.schema;
        this.root = env.root || this;
        this.baseId = env.baseId ?  ? resolve_1.normalizeId(schema ? .$id : )
            :
                this.schemaPath = env.schemaPath
            :
                this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema ? .$async
            :
                this.refs = {};
    }
    this;
    Ajv, sch;
    SchemaEnv;
    SchemaEnv;
    {
        // TODO refactor - remove compilations
        var _sch = getCompilingSchema.call(this, sch);
        if (_sch)
            return _sch;
        var rootId = resolve_1.getFullPath(sch.root.baseId); // TODO if getFullPath removed 1 tests fails
        var _a = this.opts.code, es5 = _a.es5, lines = _a.lines;
        var ownProperties = this.opts.ownProperties;
        var gen = new codegen_1.CodeGen(this.scope, { es5: es5, lines: lines, ownProperties: ownProperties });
        var _ValidationError;
        if (sch.$async) {
            _ValidationError = gen.scopeValue("Error", {
                ref: validation_error_1.default,
                code: (_b = ["require(\"ajv/dist/runtime/validation_error\").default"], _b.raw = ["require(\"ajv/dist/runtime/validation_error\").default"], codegen_1._(_b)),
            });
        }
        var validateName = gen.scopeName("validate");
        sch.validateName = validateName;
        var schemaCxt = {
            gen: gen,
            allErrors: this.opts.allErrors,
            data: names_1.default.data,
            parentData: names_1.default.parentData,
            parentDataProperty: names_1.default.parentDataProperty,
            dataNames: [names_1.default.data],
            dataPathArr: [codegen_1.nil],
            dataLevel: 0,
            dataTypes: [],
            definedProperties: new Set(),
            topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true
                ? { ref: sch.schema, code: codegen_1.stringify(sch.schema) }
                : { ref: sch.schema }),
            validateName: validateName,
            ValidationError: _ValidationError,
            schema: sch.schema,
            schemaEnv: sch,
            rootId: rootId,
            baseId: sch.baseId || rootId,
            schemaPath: codegen_1.nil,
            errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
            errorPath: (_c = ["\"\""], _c.raw = ["\"\""], codegen_1._(_c)),
            opts: this.opts,
            self: this,
        };
        var sourceCode;
        try {
            this._compilations.add(sch);
            validate_1.validateFunctionCode(schemaCxt);
            gen.optimize(this.opts.code.optimize);
            // gen.optimize(1)
            var validateCode = gen.toString();
            sourceCode = gen.scopeRefs(names_1.default.scope) + "return " + validateCode;
            // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))
            if (this.opts.code.process)
                sourceCode = this.opts.code.process(sourceCode, sch);
            // console.log("\n\n\n *** \n", sourceCode)
            var makeValidate = new Function("" + names_1.default.self, "" + names_1.default.scope, sourceCode);
            var validate = makeValidate(this, this.scope.get());
            this.scope.value(validateName, { ref: validate });
            validate.errors = null;
            validate.schema = sch.schema;
            validate.schemaEnv = sch;
            if (sch.$async)
                (validate);
            as;
            AsyncValidateFunction;
            $async = true;
            if (this.opts.code.source === true) {
                validate.source = { validateName: validateName, validateCode: validateCode, scopeValues: gen._values };
            }
            if (this.opts.unevaluated) {
                var props = schemaCxt.props, items = schemaCxt.items;
                validate.evaluated = {
                    props: props instanceof codegen_1.Name ? undefined : props,
                    items: items instanceof codegen_1.Name ? undefined : items,
                    dynamicProps: props instanceof codegen_1.Name,
                    dynamicItems: items instanceof codegen_1.Name,
                };
                if (validate.source)
                    validate.source.evaluated = codegen_1.stringify(validate.evaluated);
            }
            sch.validate = validate;
            return sch;
        }
        catch (e) {
            delete sch.validate;
            delete sch.validateName;
            if (sourceCode)
                this.logger.error("Error compiling schema, function code:", sourceCode);
            // console.log("\n\n\n *** \n", sourceCode, this.opts)
            throw e;
        }
        finally {
            this._compilations.delete(sch);
        }
    }
    this;
    Ajv,
        root;
    SchemaEnv,
        baseId;
    string,
        ref;
    string;
    AnySchema | SchemaEnv | undefined;
    {
        ref = resolve_1.resolveUrl(baseId, ref);
        var schOrFunc = root.refs[ref];
        if (schOrFunc)
            return schOrFunc;
        var _sch = resolve.call(this, root, ref);
        if (_sch === undefined) {
            var schema = root.localRefs ? .[ref]
                :
            ; // TODO maybe localRefs should hold SchemaEnv
            if (schema)
                _sch = new SchemaEnv({ schema: schema, root: root, baseId: baseId });
        }
        if (_sch === undefined)
            return;
        return (root.refs[ref] = inlineOrCompile.call(this, _sch));
    }
    this;
    Ajv, sch;
    SchemaEnv;
    AnySchema | SchemaEnv;
    {
        if (resolve_1.inlineRef(sch.schema, this.opts.inlineRefs))
            return sch.schema;
        return sch.validate ? sch : compileSchema.call(this, sch);
    }
    this;
    Ajv, schEnv;
    SchemaEnv;
    SchemaEnv | void {
        for: function (, of) {
            if ( === void 0) {  = sch; }
            if (of === void 0) { of = this._compilations; }
            if (sameSchemaEnv(sch, schEnv))
                return sch;
        }
    };
    function sameSchemaEnv(s1, s2) {
        return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    this;
    Ajv,
        root;
    SchemaEnv,
        ref;
    string; // reference to resolve
    SchemaEnv | undefined;
    {
        var sch;
        while (typeof (sch = this.refs[ref]) == "string")
            ref = sch;
        return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    this;
    Ajv,
        root;
    SchemaEnv,
        ref;
    string; // reference to resolve
    SchemaEnv | undefined;
    {
        var p = URI.parse(ref);
        var refPath = resolve_1._getFullPath(p);
        var baseId = resolve_1.getFullPath(root.baseId);
        // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests
        if (Object.keys(root.schema).length > 0 && refPath === baseId) {
            return getJsonPointer.call(this, p, root);
        }
        var id = resolve_1.normalizeId(refPath);
        var schOrRef = this.refs[id] || this.schemas[id];
        if (typeof schOrRef == "string") {
            var sch = resolveSchema.call(this, root, schOrRef);
            if (typeof sch ? .schema !== "object" : )
                return;
            return getJsonPointer.call(this, p, sch);
        }
        if (typeof schOrRef ? .schema !== "object" : )
            return;
        if (!schOrRef.validate)
            compileSchema.call(this, schOrRef);
        if (id === resolve_1.normalizeId(ref)) {
            var schema = schOrRef.schema;
            if (schema.$id)
                baseId = resolve_1.resolveUrl(baseId, schema.$id);
            return new SchemaEnv({ schema: schema, root: root, baseId: baseId });
        }
        return getJsonPointer.call(this, p, schOrRef);
    }
    var PREVENT_SCOPE_CHANGE = new Set([
        "properties",
        "patternProperties",
        "enum",
        "dependencies",
        "definitions",
    ]);
    this;
    Ajv,
        parsedRef;
    URI.URIComponents,
        { baseId: baseId, schema: schema, root: root };
    SchemaEnv;
    SchemaEnv | undefined;
    {
        if (parsedRef.fragment ? .[0] !== "/" : )
            return;
        for (var _i = 0, _d = parsedRef.fragment.slice(1).split("/"); _i < _d.length; _i++) {
            var part = _d[_i];
            if (typeof schema == "boolean")
                return;
            schema = schema[util_1.unescapeFragment(part)];
            if (schema === undefined)
                return;
            // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?
            if (!PREVENT_SCOPE_CHANGE.has(part) && typeof schema == "object" && schema.$id) {
                baseId = resolve_1.resolveUrl(baseId, schema.$id);
            }
        }
        var env;
        if (typeof schema != "boolean" && schema.$ref && !util_1.schemaHasRulesButRef(schema, this.RULES)) {
            var $ref = resolve_1.resolveUrl(baseId, schema.$ref);
            env = resolveSchema.call(this, root, $ref);
        }
        // even though resolution failed we need to return SchemaEnv to throw exception
        // so that compileAsync loads missing schema.
        env = env || new SchemaEnv({ schema: schema, root: root, baseId: baseId });
        if (env.schema !== env.root.schema)
            return env;
        return undefined;
    }
    var _b, _c;
});
