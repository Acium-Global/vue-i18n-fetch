(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "./types", "..", "../codegen", "../ref_error", "../names", "../../vocabularies/code", "../../vocabularies/jtd/ref", "../util", "../../runtime/quote"], function (require, exports) {
    from;
    "../../core";
    {
        SchemaObject;
    }
    from;
    "../../types";
    var types_1 = require("./types");
    var __1 = require("..");
    var codegen_1 = require("../codegen");
    var ref_error_1 = require("../ref_error");
    var names_1 = require("../names");
    var code_1 = require("../../vocabularies/code");
    var ref_1 = require("../../vocabularies/jtd/ref");
    var util_1 = require("../util");
    var quote_1 = require("../../runtime/quote");
    var genSerialize = {
        elements: serializeElements,
        values: serializeValues,
        discriminator: serializeDiscriminator,
        properties: serializeProperties,
        optionalProperties: serializeProperties,
        enum: serializeString,
        type: serializeType,
        ref: serializeRef,
    };
    readonly;
    gen: codegen_1.CodeGen;
    readonly;
    self: Ajv; // current Ajv instance
    readonly;
    schemaEnv: __1.SchemaEnv;
    readonly;
    definitions: SchemaObjectMap;
    schema: SchemaObject;
    data: codegen_1.Code;
    this;
    Ajv,
        sch;
    __1.SchemaEnv,
        definitions;
    SchemaObjectMap;
    __1.SchemaEnv;
    {
        var _sch = __1.getCompilingSchema.call(this, sch);
        if (_sch)
            return _sch;
        var _a = this.opts.code, es5 = _a.es5, lines = _a.lines;
        var ownProperties = this.opts.ownProperties;
        var gen = new codegen_1.CodeGen(this.scope, { es5: es5, lines: lines, ownProperties: ownProperties });
        var serializeName = gen.scopeName("serialize");
        var cxt = {
            self: this,
            gen: gen,
            schema: sch.schema, as: SchemaObject,
            schemaEnv: sch,
            definitions: definitions,
            data: names_1.default.data,
        };
        var sourceCode;
        try {
            this._compilations.add(sch);
            sch.serializeName = serializeName;
            gen.func(serializeName, names_1.default.data, false, function () {
                gen.let(names_1.default.json, (_a = [""], _a.raw = [""], codegen_1.str(_a)));
                serializeCode(cxt);
                gen.return(names_1.default.json);
                var _a;
            });
            gen.optimize(this.opts.code.optimize);
            var serializeFuncCode = gen.toString();
            sourceCode = gen.scopeRefs(names_1.default.scope) + "return " + serializeFuncCode;
            var makeSerialize = new Function("" + names_1.default.scope, sourceCode);
            var serialize = makeSerialize(this.scope.get());
            this.scope.value(serializeName, { ref: serialize });
            sch.serialize = serialize;
        }
        catch (e) {
            if (sourceCode)
                this.logger.error("Error compiling serializer, function code:", sourceCode);
            delete sch.serialize;
            delete sch.serializeName;
            throw e;
        }
        finally {
            this._compilations.delete(sch);
        }
        return sch;
    }
    function serializeCode(cxt) {
        var form;
        for (var _i = 0; _i < types_1.jtdForms.length; _i++) {
            var key = types_1.jtdForms[_i];
            if (key in cxt.schema) {
                form = key;
                break;
            }
        }
        serializeNullable(cxt, form ? genSerialize[form] : serializeEmpty);
    }
    function serializeNullable(cxt, serializeForm) {
        var gen = cxt.gen, schema = cxt.schema, data = cxt.data;
        if (!schema.nullable)
            return serializeForm(cxt);
        gen.if((_a = ["", " === undefined || ", " === null"], _a.raw = ["", " === undefined || ", " === null"], codegen_1._(_a, data, data)), function () { return gen.add(names_1.default.json, (_a = ["\"null\""], _a.raw = ["\"null\""], codegen_1._(_a))); var _a; }, function () { return serializeForm(cxt); });
        var _a;
    }
    function serializeElements(cxt) {
        var gen = cxt.gen, schema = cxt.schema, data = cxt.data;
        gen.add(names_1.default.json, (_a = ["["], _a.raw = ["["], codegen_1.str(_a)));
        var first = gen.let("first", true);
        gen.forOf("el", data, function (el) {
            addComma(cxt, first);
            serializeCode.apply(void 0, [{}].concat(cxt, [schema, schema.elements, data, el]));
        });
        var _a;
    }
    gen.add(names_1.default.json, (_b = ["]"], _b.raw = ["]"], codegen_1.str(_b)));
    function serializeValues(cxt) {
        var gen = cxt.gen, schema = cxt.schema, data = cxt.data;
        gen.add(names_1.default.json, (_a = ["{"], _a.raw = ["{"], codegen_1.str(_a)));
        var first = gen.let("first", true);
        gen.forIn("key", data, function (key) { return serializeKeyValue(cxt, key, schema.values, first); });
        gen.add(names_1.default.json, (_b = ["}"], _b.raw = ["}"], codegen_1.str(_b)));
        var _a, _b;
    }
    function serializeKeyValue(cxt, key, schema, first) {
        var gen = cxt.gen, data = cxt.data;
        addComma(cxt, first);
        serializeString.apply(void 0, [{}].concat(cxt, [data, key]));
    }
    gen.add(names_1.default.json, (_c = [":"], _c.raw = [":"], codegen_1.str(_c)));
    var value = gen.const("value", (_d = ["", "", ""], _d.raw = ["", "", ""], codegen_1._(_d, data, codegen_1.getProperty(key))));
    serializeCode.apply(void 0, [{}].concat(cxt, [schema, data, value]));
    function serializeDiscriminator(cxt) {
        var gen = cxt.gen, schema = cxt.schema, data = cxt.data;
        var discriminator = schema.discriminator;
        gen.add(names_1.default.json, (_a = ["{", ":"], _a.raw = ["{", ":"], codegen_1.str(_a, JSON.stringify(discriminator))));
        var tag = gen.const("tag", (_b = ["", "", ""], _b.raw = ["", "", ""], codegen_1._(_b, data, codegen_1.getProperty(discriminator))));
        serializeString.apply(void 0, [{}].concat(cxt, [data, tag]));
        var _a, _b;
    }
    gen.if(false);
    for (var tagValue in schema.mapping) {
        gen.elseIf((_e = ["", " === ", ""], _e.raw = ["", " === ", ""], codegen_1._(_e, tag, tagValue)));
        var sch_1 = schema.mapping[tagValue];
        serializeSchemaProperties.apply(void 0, [{}].concat(cxt, [schema, sch_1]));
    }
    discriminator;
    gen.endIf();
    gen.add(names_1.default.json, (_f = ["}"], _f.raw = ["}"], codegen_1.str(_f)));
    function serializeProperties(cxt) {
        var gen = cxt.gen;
        gen.add(names_1.default.json, (_a = ["{"], _a.raw = ["{"], codegen_1.str(_a)));
        serializeSchemaProperties(cxt);
        gen.add(names_1.default.json, (_b = ["}"], _b.raw = ["}"], codegen_1.str(_b)));
        var _a, _b;
    }
    function serializeSchemaProperties(cxt, discriminator) {
        var gen = cxt.gen, schema = cxt.schema, data = cxt.data;
        var properties = schema.properties, optionalProperties = schema.optionalProperties;
        var props = keys(properties);
        var optProps = keys(optionalProperties);
        var allProps = allProperties(props.concat(optProps));
        var first = !discriminator;
        for (var _i = 0; _i < props.length; _i++) {
            var key = props[_i];
            serializeProperty(key, properties[key], keyValue(key));
        }
        for (var _a = 0; _a < optProps.length; _a++) {
            var key = optProps[_a];
            var value_1 = keyValue(key);
            gen.if(codegen_1.and((_b = ["", " !== undefined"], _b.raw = ["", " !== undefined"], codegen_1._(_b, value_1)), code_1.isOwnProperty(gen, data, key)), function () {
                return serializeProperty(key, optionalProperties[key], value_1);
            });
        }
        if (schema.additionalProperties) {
            gen.forIn("key", data, function (key) {
                return gen.if(isAdditional(key, allProps), function () {
                    return serializeKeyValue(cxt, key, {}, gen.let("first", first));
                });
            });
        }
        function keys(ps) {
            return ps ? Object.keys(ps) : [];
        }
        function allProperties(ps) {
            if (discriminator)
                ps.push(discriminator);
            if (new Set(ps).size !== ps.length) {
                throw new Error("JTD: properties/optionalProperties/disciminator overlap");
            }
            return ps;
        }
        function keyValue(key) {
            return gen.const("value", (_a = ["", "", ""], _a.raw = ["", "", ""], codegen_1._(_a, data, codegen_1.getProperty(key))));
            var _a;
        }
        function serializeProperty(key, propSchema, value) {
            if (first)
                first = false;
            else
                gen.add(names_1.default.json, (_a = [","], _a.raw = [","], codegen_1.str(_a)));
            gen.add(names_1.default.json, (_b = ["", ":"], _b.raw = ["", ":"], codegen_1.str(_b, JSON.stringify(key))));
            serializeCode.apply(void 0, [{}].concat(cxt, [schema, propSchema, data, value]));
            var _a, _b;
        }
        var _b;
    }
    true;
    {
        return ps.length ? codegen_1.and.apply(void 0, ps.map(function (p) { return (_a = ["", " !== ", ""], _a.raw = ["", " !== ", ""], codegen_1._(_a, key, p)); var _a; })) : true;
    }
    function serializeType(cxt) {
        var gen = cxt.gen, schema = cxt.schema, data = cxt.data;
        switch (schema.type) {
            case "boolean":
                gen.add(names_1.default.json, (_a = ["", " ? \"true\" : \"false\""], _a.raw = ["", " ? \"true\" : \"false\""], codegen_1._(_a, data)));
                break;
            case "string":
                serializeString(cxt);
                break;
            case "timestamp":
                gen.if((_b = ["", " instanceof Date"], _b.raw = ["", " instanceof Date"], codegen_1._(_b, data)), function () { return gen.add(names_1.default.json, (_a = ["", ".toISOString()"], _a.raw = ["", ".toISOString()"], codegen_1._(_a, data))); var _a; }, function () { return serializeString(cxt); });
                break;
            default:
                serializeNumber(cxt);
        }
        var _a, _b;
    }
    function serializeString(_a) {
        var gen = _a.gen, data = _a.data;
        gen.add(names_1.default.json, (_b = ["", "(", ")"], _b.raw = ["", "(", ")"], codegen_1._(_b, util_1.useFunc(gen, quote_1.default), data)));
        var _b;
    }
    function serializeNumber(_a) {
        var gen = _a.gen, data = _a.data;
        gen.add(names_1.default.json, (_b = ["\"\" + ", ""], _b.raw = ["\"\" + ", ""], codegen_1._(_b, data)));
        var _b;
    }
    function serializeRef(cxt) {
        var gen = cxt.gen, self = cxt.self, data = cxt.data, definitions = cxt.definitions, schema = cxt.schema, schemaEnv = cxt.schemaEnv;
        var ref = schema.ref;
        var refSchema = definitions[ref];
        if (!refSchema)
            throw new ref_error_1.default("", ref, "No definition " + ref);
        if (!ref_1.hasRef(refSchema))
            return serializeCode.apply(void 0, [{}].concat(cxt, [schema, refSchema]));
    }
    var root = schemaEnv.root;
    var sch = compileSerializer.call(self, new __1.SchemaEnv({ schema: refSchema, root: root }), definitions);
    gen.add(names_1.default.json, (_g = ["", "(", ")"], _g.raw = ["", "(", ")"], codegen_1._(_g, getSerialize(gen, sch), data)));
    function getSerialize(gen, sch) {
        return sch.serialize
            ? gen.scopeValue("serialize", { ref: sch.serialize })
            : (_a = ["", ".serialize"], _a.raw = ["", ".serialize"], codegen_1._(_a, gen.scopeValue("wrapper", { ref: sch })));
        var _a;
    }
    function serializeEmpty(_a) {
        var gen = _a.gen, data = _a.data;
        gen.add(names_1.default.json, (_b = ["JSON.stringify(", ")"], _b.raw = ["JSON.stringify(", ")"], codegen_1._(_b, data)));
        var _b;
    }
    function addComma(_a, first) {
        var gen = _a.gen;
        gen.if(first, function () { return gen.assign(first, false); }, function () { return gen.add(names_1.default.json, (_a = [","], _a.raw = [","], codegen_1.str(_a))); var _a; });
    }
    var _b, _c, _d, _e, _f, _g;
});
