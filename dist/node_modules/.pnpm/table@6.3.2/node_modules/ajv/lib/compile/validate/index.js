(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "./boolSchema", "./dataType", "./dataType", "../codegen", "../names", "../resolve", "../util"], function (require, exports) {
    var type = ;
    {
        AddedKeywordDefinition,
            AnySchema,
            AnySchemaObject,
            KeywordErrorCxt,
            KeywordCxtParams,
        ;
    }
    from;
    "../../types";
    {
        SchemaCxt, SchemaObjCxt;
    }
    from;
    "..";
    {
        InstanceOptions;
    }
    from;
    "../../core";
    var boolSchema_1 = require("./boolSchema");
    var dataType_1 = require("./dataType");
    var dataType_2 = require("./dataType");
    var codegen_1 = require("../codegen");
    var names_1 = require("../names");
    var resolve_1 = require("../resolve");
    var util_1 = require("../util");
    {
        JSONType, Rule, RuleGroup;
    }
    from;
    "../rules";
    // schema compilation - generates validation function, subschemaCode (below) is used for subschemas
    function validateFunctionCode(it) {
        if (isSchemaObj(it)) {
            checkKeywords(it);
            if (schemaCxtHasRules(it)) {
                topSchemaObjCode(it);
                return;
            }
        }
        validateFunction(it, function () { return boolSchema_1.topBoolOrEmptySchema(it); });
    }
    exports.validateFunctionCode = validateFunctionCode;
    function validateFunction(_a, body) {
        var gen = _a.gen, validateName = _a.validateName, schema = _a.schema, schemaEnv = _a.schemaEnv, opts = _a.opts;
        if (opts.code.es5) {
            gen.func(validateName, (_b = ["", ", ", ""], _b.raw = ["", ", ", ""], codegen_1._(_b, names_1.default.data, names_1.default.valCxt)), schemaEnv.$async, function () {
                gen.code((_a = ["\"use strict\"; ", ""], _a.raw = ["\"use strict\"; ", ""], codegen_1._(_a, funcSourceUrl(schema, opts))));
                destructureValCxtES5(gen, opts);
                gen.code(body);
                var _a;
            });
        }
        else {
            gen.func(validateName, (_c = ["", ", ", ""], _c.raw = ["", ", ", ""], codegen_1._(_c, names_1.default.data, destructureValCxt(opts))), schemaEnv.$async, function () {
                return gen.code(funcSourceUrl(schema, opts)).code(body);
            });
        }
        var _b, _c;
    }
    function destructureValCxt(opts) {
        return (_a = ["{", "=\"\", ", ", ", ", ", "=", "", "}={}"], _a.raw = ["{", "=\"\", ", ", ", ", ", "=", "", "}={}"], codegen_1._(_a, names_1.default.instancePath, names_1.default.parentData, names_1.default.parentDataProperty, names_1.default.rootData, names_1.default.data, opts.dynamicRef ? (_b = [", ", "={}"], _b.raw = [", ", "={}"], codegen_1._(_b, names_1.default.dynamicAnchors)) : codegen_1.nil));
        var _a, _b;
    }
    function destructureValCxtES5(gen, opts) {
        gen.if(names_1.default.valCxt, function () {
            gen.var(names_1.default.instancePath, (_a = ["", ".", ""], _a.raw = ["", ".", ""], codegen_1._(_a, names_1.default.valCxt, names_1.default.instancePath)));
            gen.var(names_1.default.parentData, (_b = ["", ".", ""], _b.raw = ["", ".", ""], codegen_1._(_b, names_1.default.valCxt, names_1.default.parentData)));
            gen.var(names_1.default.parentDataProperty, (_c = ["", ".", ""], _c.raw = ["", ".", ""], codegen_1._(_c, names_1.default.valCxt, names_1.default.parentDataProperty)));
            gen.var(names_1.default.rootData, (_d = ["", ".", ""], _d.raw = ["", ".", ""], codegen_1._(_d, names_1.default.valCxt, names_1.default.rootData)));
            if (opts.dynamicRef)
                gen.var(names_1.default.dynamicAnchors, (_e = ["", ".", ""], _e.raw = ["", ".", ""], codegen_1._(_e, names_1.default.valCxt, names_1.default.dynamicAnchors)));
            var _a, _b, _c, _d, _e;
        }, function () {
            gen.var(names_1.default.instancePath, (_a = ["\"\""], _a.raw = ["\"\""], codegen_1._(_a)));
            gen.var(names_1.default.parentData, (_b = ["undefined"], _b.raw = ["undefined"], codegen_1._(_b)));
            gen.var(names_1.default.parentDataProperty, (_c = ["undefined"], _c.raw = ["undefined"], codegen_1._(_c)));
            gen.var(names_1.default.rootData, names_1.default.data);
            if (opts.dynamicRef)
                gen.var(names_1.default.dynamicAnchors, (_d = ["{}"], _d.raw = ["{}"], codegen_1._(_d)));
            var _a, _b, _c, _d;
        });
    }
    function topSchemaObjCode(it) {
        var schema = it.schema, opts = it.opts, gen = it.gen;
        validateFunction(it, function () {
            if (opts.$comment && schema.$comment)
                commentKeyword(it);
            checkNoDefault(it);
            gen.let(names_1.default.vErrors, null);
            gen.let(names_1.default.errors, 0);
            if (opts.unevaluated)
                resetEvaluated(it);
            typeAndKeywords(it);
            returnResults(it);
        });
        return;
    }
    function resetEvaluated(it) {
        // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
        var gen = it.gen, validateName = it.validateName;
        it.evaluated = gen.const("evaluated", (_a = ["", ".evaluated"], _a.raw = ["", ".evaluated"], codegen_1._(_a, validateName)));
        gen.if((_b = ["", ".dynamicProps"], _b.raw = ["", ".dynamicProps"], codegen_1._(_b, it.evaluated)), function () { return gen.assign((_a = ["", ".props"], _a.raw = ["", ".props"], codegen_1._(_a, it.evaluated)), (_b = ["undefined"], _b.raw = ["undefined"], codegen_1._(_b))); var _a, _b; });
        gen.if((_c = ["", ".dynamicItems"], _c.raw = ["", ".dynamicItems"], codegen_1._(_c, it.evaluated)), function () { return gen.assign((_a = ["", ".items"], _a.raw = ["", ".items"], codegen_1._(_a, it.evaluated)), (_b = ["undefined"], _b.raw = ["undefined"], codegen_1._(_b))); var _a, _b; });
        var _a, _b, _c;
    }
    function funcSourceUrl(schema, opts) {
        return typeof schema == "object" && schema.$id && (opts.code.source || opts.code.process)
            ? (_a = ["/*# sourceURL=", " */"], _a.raw = ["/*# sourceURL=", " */"], codegen_1._(_a, schema.$id))
            : codegen_1.nil;
        var _a;
    }
    // schema compilation - this function is used recursively to generate code for sub-schemas
    function subschemaCode(it, valid) {
        if (isSchemaObj(it)) {
            checkKeywords(it);
            if (schemaCxtHasRules(it)) {
                subSchemaObjCode(it, valid);
                return;
            }
        }
        boolSchema_1.boolOrEmptySchema(it, valid);
    }
    function schemaCxtHasRules(_a) {
        var schema = _a.schema, self = _a.self;
        if (typeof schema == "boolean")
            return !schema;
        for (var key in schema)
            if (self.RULES.all[key])
                return true;
        return false;
    }
    function isSchemaObj(it) {
        return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
        var schema = it.schema, gen = it.gen, opts = it.opts;
        if (opts.$comment && schema.$comment)
            commentKeyword(it);
        updateContext(it);
        checkAsyncSchema(it);
        var errsCount = gen.const("_errs", names_1.default.errors);
        typeAndKeywords(it, errsCount);
        // TODO var
        gen.var(valid, (_a = ["", " === ", ""], _a.raw = ["", " === ", ""], codegen_1._(_a, errsCount, names_1.default.errors)));
        var _a;
    }
    function checkKeywords(it) {
        util_1.checkUnknownRules(it);
        checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
        if (it.opts.jtd)
            return schemaKeywords(it, [], false, errsCount);
        var types = dataType_1.getSchemaTypes(it.schema);
        var checkedTypes = dataType_1.coerceAndCheckDataType(it, types);
        schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
        var schema = it.schema, errSchemaPath = it.errSchemaPath, opts = it.opts, self = it.self;
        if (schema.$ref && opts.ignoreKeywordsWithRef && util_1.schemaHasRulesButRef(schema, self.RULES)) {
            self.logger.warn("$ref: keywords ignored in schema at path \"" + errSchemaPath + "\"");
        }
    }
    function checkNoDefault(it) {
        var schema = it.schema, opts = it.opts;
        if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
            util_1.checkStrictMode(it, "default is ignored in the schema root");
        }
    }
    function updateContext(it) {
        if (it.schema.$id)
            it.baseId = resolve_1.resolveUrl(it.baseId, it.schema.$id);
    }
    function checkAsyncSchema(it) {
        if (it.schema.$async && !it.schemaEnv.$async)
            throw new Error("async schema in sync schema");
    }
    function commentKeyword(_a) {
        var gen = _a.gen, schemaEnv = _a.schemaEnv, schema = _a.schema, errSchemaPath = _a.errSchemaPath, opts = _a.opts;
        var msg = schema.$comment;
        if (opts.$comment === true) {
            gen.code((_b = ["", ".logger.log(", ")"], _b.raw = ["", ".logger.log(", ")"], codegen_1._(_b, names_1.default.self, msg)));
        }
        else if (typeof opts.$comment == "function") {
            var schemaPath = (_c = ["", "/$comment"], _c.raw = ["", "/$comment"], codegen_1.str(_c, errSchemaPath));
            var rootName = gen.scopeValue("root", { ref: schemaEnv.root });
            gen.code((_d = ["", ".opts.$comment(", ", ", ", ", ".schema)"], _d.raw = ["", ".opts.$comment(", ", ", ", ", ".schema)"], codegen_1._(_d, names_1.default.self, msg, schemaPath, rootName)));
        }
        var _b, _c, _d;
    }
    function returnResults(it) {
        var gen = it.gen, schemaEnv = it.schemaEnv, validateName = it.validateName, ValidationError = it.ValidationError, opts = it.opts;
        if (schemaEnv.$async) {
            // TODO assign unevaluated
            gen.if((_a = ["", " === 0"], _a.raw = ["", " === 0"], codegen_1._(_a, names_1.default.errors)), function () { return gen.return(names_1.default.data); }, function () { return gen.throw((_a = ["new ", ""], _a.raw = ["new ", ""], codegen_1._(_a, ValidationError)), as, codegen_1.Name); var _a; });
        }
        ($);
        {
            names_1.default.vErrors;
        }
        ")\n    )\n  } else {\n    gen.assign(_";
        $;
        {
            validateName;
        }
        (_b = [", N.vErrors)\n    if (opts.unevaluated) assignEvaluated(it)\n    gen.return(_"], _b.raw = [", N.vErrors)\n    if (opts.unevaluated) assignEvaluated(it)\n    gen.return(_"], errors(_b));
        $;
        {
            names_1.default.errors;
        }
         === (_c = [")\n  }\n}\n\nfunction assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {\n  if (props instanceof Name) gen.assign(_"], _c.raw = [")\n  }\n}\n\nfunction assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {\n  if (props instanceof Name) gen.assign(_"], (0)(_c));
        $;
        {
            evaluated;
        }
        (_d = [", props)\n  if (items instanceof Name) gen.assign(_"], _d.raw = [", props)\n  if (items instanceof Name) gen.assign(_"], props(_d));
        $;
        {
            evaluated;
        }
        (_e = [", items)\n}\n\nfunction schemaKeywords(\n  it: SchemaObjCxt,\n  types: JSONType[],\n  typeErrors: boolean,\n  errsCount?: Name\n): void {\n  const {gen, schema, data, allErrors, opts, self} = it\n  const {RULES} = self\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", (RULES.all.$ref as Rule).definition)) // TODO typecast\n    return\n  }\n  if (!opts.jtd) checkStrictTypes(it, types)\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group)\n    groupKeywords(RULES.post)\n  })\n\n  function groupKeywords(group: RuleGroup): void {\n    if (!shouldUseGroup(schema, group)) return\n    if (group.type) {\n      gen.if(checkDataType(group.type, data, opts.strictNumbers))\n      iterateKeywords(it, group)\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else()\n        reportTypeError(it)\n      }\n      gen.endIf()\n    } else {\n      iterateKeywords(it, group)\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if(_"], _e.raw = [", items)\n}\n\nfunction schemaKeywords(\n  it: SchemaObjCxt,\n  types: JSONType[],\n  typeErrors: boolean,\n  errsCount?: Name\n): void {\n  const {gen, schema, data, allErrors, opts, self} = it\n  const {RULES} = self\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", (RULES.all.$ref as Rule).definition)) // TODO typecast\n    return\n  }\n  if (!opts.jtd) checkStrictTypes(it, types)\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group)\n    groupKeywords(RULES.post)\n  })\n\n  function groupKeywords(group: RuleGroup): void {\n    if (!shouldUseGroup(schema, group)) return\n    if (group.type) {\n      gen.if(checkDataType(group.type, data, opts.strictNumbers))\n      iterateKeywords(it, group)\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else()\n        reportTypeError(it)\n      }\n      gen.endIf()\n    } else {\n      iterateKeywords(it, group)\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if(_"], items(_e));
        $;
        {
            names_1.default.errors;
        }
         === $;
        {
            errsCount || 0;
        }
        ")\n  }\n}\n\nfunction iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {\n  const {\n    gen,\n    schema,\n    opts: {useDefaults},\n  } = it\n  if (useDefaults) assignDefaults(it, group.type)\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (shouldUseRule(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type)\n      }\n    }\n  })\n}\n\nfunction checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return\n  checkContextTypes(it, types)\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)\n  checkKeywordTypes(it, it.dataTypes)\n}\n\nfunction checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (!types.length) return\n  if (!it.dataTypes.length) {\n    it.dataTypes = types\n    return\n  }\n  types.forEach((t) => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, ";
        type;
        "${t}";
        codegen_1.not;
        allowed;
        by;
        context;
        "${it.dataTypes.join(", (_f = [")\n    }\n  })\n  it.dataTypes = it.dataTypes.filter((t) => includesType(types, t))\n}\n\nfunction checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\")\n  }\n}\n\nfunction checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  const rules = it.self.RULES.all\n  for (const keyword in rules) {\n    const rule = rules[keyword]\n    if (typeof rule == \"object\" && shouldUseRule(it.schema, rule)) {\n      const {type} = rule.definition\n      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n        strictTypesError(it, "], _f.raw = [")\n    }\n  })\n  it.dataTypes = it.dataTypes.filter((t) => includesType(types, t))\n}\n\nfunction checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\")\n  }\n}\n\nfunction checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  const rules = it.self.RULES.all\n  for (const keyword in rules) {\n    const rule = rules[keyword]\n    if (typeof rule == \"object\" && shouldUseRule(it.schema, rule)) {\n      const {type} = rule.definition\n      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n        strictTypesError(it, "], (")}")(_f));
        missing;
        type;
        "${type.join(", ")}";
        for (keyword; (_g = [")\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {\n  return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"))\n}\n\nfunction includesType(ts: JSONType[], t: JSONType): boolean {\n  return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"))\n}\n\nfunction strictTypesError(it: SchemaObjCxt, msg: string): void {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n  msg += "], _g.raw = [")\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {\n  return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"))\n}\n\nfunction includesType(ts: JSONType[], t: JSONType): boolean {\n  return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"))\n}\n\nfunction strictTypesError(it: SchemaObjCxt, msg: string): void {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n  msg += "], ("${keyword}")(_g)); at)
            (_h = ["\n  checkStrictMode(it, msg, it.opts.strictTypes)\n}\n\nexport class KeywordCxt implements KeywordErrorCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean\n  readonly keyword: string\n  readonly data: Name // Name referencing the current level of the data instance\n  readonly $data?: string | false\n  schema: any // keyword value in the schema\n  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value\n  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)\n  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema\n  readonly parentSchema: AnySchemaObject\n  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,\n  // requires option trackErrors in keyword definition\n  params: KeywordCxtParams // object to pass parameters to error messages from keyword code\n  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)\n  readonly def: AddedKeywordDefinition\n\n  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {\n    validateKeywordUsage(it, def, keyword)\n    this.gen = it.gen\n    this.allErrors = it.allErrors\n    this.keyword = keyword\n    this.data = it.data\n    this.schema = it.schema[keyword]\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data\n    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)\n    this.schemaType = def.schemaType\n    this.parentSchema = it.schema\n    this.params = {}\n    this.it = it\n    this.def = def\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it))\n    } else {\n      this.schemaCode = this.schemaValue\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error("], _h.raw = ["\n  checkStrictMode(it, msg, it.opts.strictTypes)\n}\n\nexport class KeywordCxt implements KeywordErrorCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean\n  readonly keyword: string\n  readonly data: Name // Name referencing the current level of the data instance\n  readonly $data?: string | false\n  schema: any // keyword value in the schema\n  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value\n  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)\n  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema\n  readonly parentSchema: AnySchemaObject\n  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,\n  // requires option trackErrors in keyword definition\n  params: KeywordCxtParams // object to pass parameters to error messages from keyword code\n  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)\n  readonly def: AddedKeywordDefinition\n\n  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {\n    validateKeywordUsage(it, def, keyword)\n    this.gen = it.gen\n    this.allErrors = it.allErrors\n    this.keyword = keyword\n    this.data = it.data\n    this.schema = it.schema[keyword]\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data\n    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)\n    this.schemaType = def.schemaType\n    this.parentSchema = it.schema\n    this.params = {}\n    this.it = it\n    this.def = def\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it))\n    } else {\n      this.schemaCode = this.schemaValue\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error("], "${schemaPath}"(strictTypes)(_h));
        $;
        {
            keyword;
        }
        value;
        must;
        be;
        $;
        {
            JSON.stringify(def.schemaType);
        }
        ")\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", N.errors)\n    }\n  }\n\n  result(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.gen.if(not(condition))\n    if (failAction) failAction()\n    else this.error()\n    if (successAction) {\n      this.gen.else()\n      successAction()\n      if (this.allErrors) this.gen.endIf()\n    } else {\n      if (this.allErrors) this.gen.endIf()\n      else this.gen.else()\n    }\n  }\n\n  pass(condition: Code, failAction?: () => void): void {\n    this.result(condition, undefined, failAction)\n  }\n\n  fail(condition?: Code): void {\n    if (condition === undefined) {\n      this.error()\n      if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize\n      return\n    }\n    this.gen.if(condition)\n    this.error()\n    if (this.allErrors) this.gen.endIf()\n    else this.gen.else()\n  }\n\n  fail$data(condition: Code): void {\n    if (!this.$data) return this.fail(condition)\n    const {schemaCode} = this\n    this.fail(_";
        $;
        {
            schemaCode;
        }
         !== undefined && ($);
        {
            codegen_1.or(this.invalid$data(), condition);
        }
        ")\n  }\n\n  error(append?: boolean, errorParams?: KeywordCxtParams, errorPaths?: ErrorPaths): void {\n    if (errorParams) {\n      this.setParams(errorParams)\n      this._error(append, errorPaths)\n      this.setParams({})\n      return\n    }\n    this._error(append, errorPaths)\n  }\n\n  private _error(append?: boolean, errorPaths?: ErrorPaths): void {\n    ;(append ? reportExtraError : reportError)(this, this.def.error, errorPaths)\n  }\n\n  $dataError(): void {\n    reportError(this, this.def.$dataError || keyword$DataError)\n  }\n\n  reset(): void {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition')\n    resetErrorsCount(this.gen, this.errsCount)\n  }\n\n  ok(cond: Code | boolean): void {\n    if (!this.allErrors) this.gen.if(cond)\n  }\n\n  setParams(obj: KeywordCxtParams, assign?: true): void {\n    if (assign) Object.assign(this.params, obj)\n    else this.params = obj\n  }\n\n  block$data(valid: Name, codeBlock: () => void, $dataValid: Code = nil): void {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid)\n      codeBlock()\n    })\n  }\n\n  check$data(valid: Name = nil, $dataValid: Code = nil): void {\n    if (!this.$data) return\n    const {gen, schemaCode, schemaType, def} = this\n    gen.if(or(_";
        $;
        {
            schemaCode;
        }
         === (_j = [", $dataValid))\n    if (valid !== nil) gen.assign(valid, true)\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data())\n      this.$dataError()\n      if (valid !== nil) gen.assign(valid, false)\n    }\n    gen.else()\n  }\n\n  invalid$data(): Code {\n    const {gen, schemaCode, schemaType, def, it} = this\n    return or(wrong$DataType(), invalid$DataSchema())\n\n    function wrong$DataType(): Code {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof Name)) throw new Error(\"ajv implementation error\")\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType]\n        return _"], _j.raw = [", $dataValid))\n    if (valid !== nil) gen.assign(valid, true)\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data())\n      this.$dataError()\n      if (valid !== nil) gen.assign(valid, false)\n    }\n    gen.else()\n  }\n\n  invalid$data(): Code {\n    const {gen, schemaCode, schemaType, def, it} = this\n    return or(wrong$DataType(), invalid$DataSchema())\n\n    function wrong$DataType(): Code {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof Name)) throw new Error(\"ajv implementation error\")\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType]\n        return _"], undefined(_j));
        $;
        {
            dataType_2.checkDataTypes(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong);
        }
        "\n      }\n      return nil\n    }\n\n    function invalid$DataSchema(): Code {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {ref: def.validateSchema}) // TODO value.code for standalone\n        return _";
        !$;
        {
            validateSchemaRef;
        }
        ($);
        {
            schemaCode;
        }
        "\n      }\n      return nil\n    }\n  }\n\n  subschema(appl: SubschemaArgs, valid: Name): SchemaCxt {\n    const subschema = getSubschema(this.it, appl)\n    extendSubschemaData(subschema, this.it, appl)\n    extendSubschemaMode(subschema, appl)\n    const nextContext = {...this.it, ...subschema, items: undefined, props: undefined}\n    subschemaCode(nextContext, valid)\n    return nextContext\n  }\n\n  mergeEvaluated(schemaCxt: SchemaCxt, toName?: typeof Name): void {\n    const {it, gen} = this\n    if (!it.opts.unevaluated) return\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt: SchemaCxt, valid: Name): boolean | void {\n    const {it, gen} = this\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, Name))\n      return true\n    }\n  }\n}\n\nfunction keywordCode(\n  it: SchemaObjCxt,\n  keyword: string,\n  def: AddedKeywordDefinition,\n  ruleType?: JSONType\n): void {\n  const cxt = new KeywordCxt(it, def, keyword)\n  if (\"code\" in def) {\n    def.code(cxt, ruleType)\n  } else if (cxt.$data && def.validate) {\n    funcKeywordCode(cxt, def)\n  } else if (\"macro\" in def) {\n    macroKeywordCode(cxt, def)\n  } else if (def.compile || def.validate) {\n    funcKeywordCode(cxt, def)\n  }\n}\n\nconst JSON_POINTER = /^/(?:[^~]|~0|~1)*$/\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|/(?:[^~]|~0|~1)*)?$/\nexport function getData(\n  $data: string,\n  {dataLevel, dataNames, dataPathArr}: SchemaCxt\n): Code | number {\n  let jsonPointer\n  let data: Code\n  if ($data === \"\") return N.rootData\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(";
        Invalid;
        JSON - pointer;
        $;
        {
            $data;
        }
        ")\n    jsonPointer = $data\n    data = N.rootData\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data)\n    if (!matches) throw new Error(";
        Invalid;
        JSON - pointer;
        $;
        {
            $data;
        }
        ")\n    const up: number = +matches[1]\n    jsonPointer = matches[2]\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up))\n      return dataPathArr[dataLevel - up]\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up))\n    data = dataNames[dataLevel - up]\n    if (!jsonPointer) return data\n  }\n\n  let expr = data\n  const segments = jsonPointer.split(\"/\")\n  for (const segment of segments) {\n    if (segment) {\n      data = _";
        $;
        {
            data;
        }
        $;
        {
            codegen_1.getProperty(util_1.unescapeJsonPointer(segment));
        }
        "\n      expr = _";
        $;
        {
            expr;
        }
         && $;
        {
            data;
        }
        "\n    }\n  }\n  return expr\n\n  function errorMsg(pointerType: string, up: number): string {\n    return ";
        Cannot;
        access;
        $;
        {
            pointerType;
        }
        $;
        {
            up;
        }
        levels;
        up, current;
        level;
        is;
        $;
        {
            dataLevel;
        }
        "\n  }\n}\n";
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    }
});
