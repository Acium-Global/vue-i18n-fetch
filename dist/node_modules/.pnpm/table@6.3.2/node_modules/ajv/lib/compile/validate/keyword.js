(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "../codegen", "../names", "../../vocabularies/code"], function (require, exports) {
    {
        KeywordCxt;
    }
    from;
    ".";
    {
        AnySchema,
            SchemaValidateFunction,
            AnyValidateFunction,
            AddedKeywordDefinition,
            MacroKeywordDefinition,
            FuncKeywordDefinition,
        ;
    }
    from;
    "../../types";
    {
        SchemaObjCxt;
    }
    from;
    "..";
    var codegen_1 = require("../codegen");
    var names_1 = require("../names");
    {
        JSONType;
    }
    from;
    "../rules";
    var code_1 = require("../../vocabularies/code");
    function macroKeywordCode(cxt, def) {
        var gen = cxt.gen, keyword = cxt.keyword, schema = cxt.schema, parentSchema = cxt.parentSchema, it = cxt.it;
        var macroSchema = def.macro.call(it.self, schema, parentSchema, it);
        var schemaRef = useKeyword(gen, keyword, macroSchema);
        if (it.opts.validateSchema !== false)
            it.self.validateSchema(macroSchema, true);
        var valid = gen.name("valid");
        cxt.subschema({
            schema: macroSchema,
            schemaPath: codegen_1.nil,
            errSchemaPath: it.errSchemaPath + "/" + keyword,
            topSchemaRef: schemaRef,
            compositeRule: true,
        }, valid);
        cxt.pass(valid, function () { return cxt.error(true); });
    }
    exports.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
        var gen = cxt.gen, keyword = cxt.keyword, schema = cxt.schema, parentSchema = cxt.parentSchema, $data = cxt.$data, it = cxt.it;
        checkAsyncKeyword(it, def);
        var validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
        var validateRef = useKeyword(gen, keyword, validate);
        var valid = gen.let("valid");
        cxt.block$data(valid, validateKeyword);
        cxt.ok(def.valid ?  ? valid :  : );
        function validateKeyword() {
            if (def.errors === false) {
                assignValid();
                if (def.modifying)
                    modifyData(cxt);
                reportErrs(function () { return cxt.error(); });
            }
            else {
                var ruleErrs = def.async ? validateAsync() : validateSync();
                if (def.modifying)
                    modifyData(cxt);
                reportErrs(function () { return addErrs(cxt, ruleErrs); });
            }
        }
        function validateAsync() {
            var ruleErrs = gen.let("ruleErrs", null);
            gen.try(function () { return assignValid((_a = ["await "], _a.raw = ["await "], codegen_1._(_a))); var _a; }, function (e) {
                return gen.assign(valid, false).if((_a = ["", " instanceof ", ""], _a.raw = ["", " instanceof ", ""], codegen_1._(_a, e, it.ValidationError)), as, codegen_1.Name);
                var _a;
            });
        }
        ",\n          () => gen.assign(ruleErrs, _";
        $;
        {
            e;
        }
        (_a = ["),\n          () => gen.throw(e)\n        )\n    )\n    return ruleErrs\n  }\n\n  function validateSync(): Code {\n    const validateErrs = _"], _a.raw = ["),\n          () => gen.throw(e)\n        )\n    )\n    return ruleErrs\n  }\n\n  function validateSync(): Code {\n    const validateErrs = _"], errors(_a));
        $;
        {
            validateRef;
        }
        (_b = ["\n    gen.assign(validateErrs, null)\n    assignValid(nil)\n    return validateErrs\n  }\n\n  function assignValid(_await: Code = def.async ? _"], _b.raw = ["\n    gen.assign(validateErrs, null)\n    assignValid(nil)\n    return validateErrs\n  }\n\n  function assignValid(_await: Code = def.async ? _"], errors(_b));
        (_c = [" : nil): void {\n    const passCxt = it.opts.passContext ? N.this : N.self\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\n    gen.assign(\n      valid,\n      _"], _c.raw = [" : nil): void {\n    const passCxt = it.opts.passContext ? N.this : N.self\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\n    gen.assign(\n      valid,\n      _"], await(_c));
        $;
        {
            _await;
        }
        $;
        {
            code_1.callValidateCode(cxt, validateRef, passCxt, passSchema);
        }
        ",\n      def.modifying\n    )\n  }\n\n  function reportErrs(errors: () => void): void {\n    gen.if(not(def.valid ?? valid), errors)\n  }\n}\n\nfunction modifyData(cxt: KeywordCxt): void {\n  const {gen, data, it} = cxt\n  gen.if(it.parentData, () => gen.assign(data, _";
        $;
        {
            it.parentData;
        }
        (_d = ["))\n}\n\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\n  const {gen} = cxt\n  gen.if(\n    _"], _d.raw = ["))\n}\n\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\n  const {gen} = cxt\n  gen.if(\n    _"], [$, { it: .parentDataProperty }](_d));
        (_e = [",\n    () => {\n      gen\n        .assign(N.vErrors, _"], _e.raw = [",\n    () => {\n      gen\n        .assign(N.vErrors, _"], Array.isArray($, { errs: errs })(_e));
        $;
        {
            names_1.default.vErrors;
        }
         === null ? $ : { errs: errs };
        $;
        {
            names_1.default.vErrors;
        }
        (_f = [")\n        .assign(N.errors, _"], _f.raw = [")\n        .assign(N.errors, _"], concat($, { errs: errs })(_f));
        $;
        {
            names_1.default.vErrors;
        }
        (_g = [")\n      extendErrors(cxt)\n    },\n    () => cxt.error()\n  )\n}\n\nfunction checkAsyncKeyword({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\n}\n\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\n  if (result === undefined) throw new Error("], _g.raw = [")\n      extendErrors(cxt)\n    },\n    () => cxt.error()\n  )\n}\n\nfunction checkAsyncKeyword({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\n}\n\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\n  if (result === undefined) throw new Error("], length(_g));
        keyword;
        "${keyword}";
        failed;
        to;
        (_h = [")\n  return gen.scopeValue(\n    \"keyword\",\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\n  )\n}\n\nexport function validSchemaType(\n  schema: unknown,\n  schemaType: JSONType[],\n  allowUndefined = false\n): boolean {\n  // TODO add tests\n  return (\n    !schemaType.length ||\n    schemaType.some((st) =>\n      st === \"array\"\n        ? Array.isArray(schema)\n        : st === \"object\"\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\n    )\n  )\n}\n\nexport function validateKeywordUsage(\n  {schema, opts, self, errSchemaPath}: SchemaObjCxt,\n  def: AddedKeywordDefinition,\n  keyword: string\n): void {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\")\n  }\n\n  const deps = def.dependencies\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error("], _h.raw = [")\n  return gen.scopeValue(\n    \"keyword\",\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\n  )\n}\n\nexport function validSchemaType(\n  schema: unknown,\n  schemaType: JSONType[],\n  allowUndefined = false\n): boolean {\n  // TODO add tests\n  return (\n    !schemaType.length ||\n    schemaType.some((st) =>\n      st === \"array\"\n        ? Array.isArray(schema)\n        : st === \"object\"\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\n    )\n  )\n}\n\nexport function validateKeywordUsage(\n  {schema, opts, self, errSchemaPath}: SchemaObjCxt,\n  def: AddedKeywordDefinition,\n  keyword: string\n): void {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\")\n  }\n\n  const deps = def.dependencies\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error("], compile(_h));
        parent;
        schema;
        must;
        have;
        dependencies;
        of;
        $;
        {
            keyword;
        }
        $;
        {
            deps.join(",");
        }
        ")\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword])\n    if (!valid) {\n      const msg =\n        ";
        keyword;
        "${keyword}";
        value;
        is;
        invalid;
        at;
        path;
        "${errSchemaPath}";
        " +\n        self.errorsText(def.validateSchema.errors)\n      if (opts.validateSchema === \"log\") self.logger.error(msg)\n      else throw new Error(msg)\n    }\n  }\n}\n";
        var _a, _b, _c, _d, _e, _f, _g, _h;
    }
    exports.funcKeywordCode = funcKeywordCode;
});
