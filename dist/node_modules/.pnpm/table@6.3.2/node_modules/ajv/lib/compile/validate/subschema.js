(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "../codegen", "../util"], function (require, exports) {
    {
        AnySchema;
    }
    from;
    "../../types";
    {
        SchemaObjCxt;
    }
    from;
    "..";
    var codegen_1 = require("../codegen");
    var util_1 = require("../util");
    {
        JSONType;
    }
    from;
    "../rules";
    function getSubschema(it, _a) {
        var keyword = _a.keyword, schemaProp = _a.schemaProp, schema = _a.schema, schemaPath = _a.schemaPath, errSchemaPath = _a.errSchemaPath, topSchemaRef = _a.topSchemaRef;
        if (keyword !== undefined && schema !== undefined) {
            throw new Error('both "keyword" and "schema" passed, only one allowed');
        }
        if (keyword !== undefined) {
            var sch = it.schema[keyword];
            return schemaProp === undefined
                ? {
                    schema: sch,
                    schemaPath: (_b = ["", "", ""], _b.raw = ["", "", ""], codegen_1._(_b, it.schemaPath, codegen_1.getProperty(keyword))),
                    errSchemaPath: it.errSchemaPath + "/" + keyword,
                }
                : {
                    schema: sch[schemaProp],
                    schemaPath: (_c = ["", "", "", ""], _c.raw = ["", "", "", ""], codegen_1._(_c, it.schemaPath, codegen_1.getProperty(keyword), codegen_1.getProperty(schemaProp))),
                    errSchemaPath: it.errSchemaPath + "/" + keyword + "/" + util_1.escapeFragment(schemaProp),
                };
        }
        if (schema !== undefined) {
            if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
                throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
            }
            return {
                schema: schema,
                schemaPath: schemaPath,
                topSchemaRef: topSchemaRef,
                errSchemaPath: errSchemaPath,
            };
        }
        throw new Error('either "keyword" or "schema" must be passed');
        var _b, _c;
    }
    exports.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, _a) {
        var dataProp = _a.dataProp, dpType = _a.dataPropType, data = _a.data, dataTypes = _a.dataTypes, propertyName = _a.propertyName;
        if (data !== undefined && dataProp !== undefined) {
            throw new Error('both "data" and "dataProp" passed, only one allowed');
        }
        var gen = it.gen;
        if (dataProp !== undefined) {
            var errorPath = it.errorPath, dataPathArr = it.dataPathArr, opts = it.opts;
            var nextData = gen.let("data", (_b = ["", "", ""], _b.raw = ["", "", ""], codegen_1._(_b, it.data, codegen_1.getProperty(dataProp))), true);
            dataContextProps(nextData);
            subschema.errorPath = (_c = ["", "", ""], _c.raw = ["", "", ""], codegen_1.str(_c, errorPath, util_1.getErrorPath(dataProp, dpType, opts.jsPropertySyntax)));
            subschema.parentDataProperty = (_d = ["", ""], _d.raw = ["", ""], codegen_1._(_d, dataProp));
            subschema.dataPathArr = dataPathArr.concat([subschema.parentDataProperty]);
        }
        if (data !== undefined) {
            var nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true); // replaceable if used once?
            dataContextProps(nextData);
            if (propertyName !== undefined)
                subschema.propertyName = propertyName;
        }
        if (dataTypes)
            subschema.dataTypes = dataTypes;
        function dataContextProps(_nextData) {
            subschema.data = _nextData;
            subschema.dataLevel = it.dataLevel + 1;
            subschema.dataTypes = [];
            it.definedProperties = new Set();
            subschema.parentData = it.data;
            subschema.dataNames = it.dataNames.concat([_nextData]);
        }
        var _b, _c, _d;
    }
    exports.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, _a) {
        var jtdDiscriminator = _a.jtdDiscriminator, jtdMetadata = _a.jtdMetadata, compositeRule = _a.compositeRule, createErrors = _a.createErrors, allErrors = _a.allErrors;
        if (compositeRule !== undefined)
            subschema.compositeRule = compositeRule;
        if (createErrors !== undefined)
            subschema.createErrors = createErrors;
        if (allErrors !== undefined)
            subschema.allErrors = allErrors;
        subschema.jtdDiscriminator = jtdDiscriminator; // not inherited
        subschema.jtdMetadata = jtdMetadata; // not inherited
    }
    exports.extendSubschemaMode = extendSubschemaMode;
});
