(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "./runtime/validation_error", "./compile/ref_error", "./compile/rules", "./compile", "./compile/codegen", "./compile/resolve", "./compile/validate/dataType", "./compile/util", "./refs/data.json"], function (require, exports) {
    var _this = this;
    var type = ;
    {
        Schema,
            AnySchema,
            AnySchemaObject,
            SchemaObject,
            AsyncSchema,
            Vocabulary,
            KeywordDefinition,
            AddedKeywordDefinition,
            AnyValidateFunction,
            ValidateFunction,
            AsyncValidateFunction,
            ErrorObject,
            Format,
            AddedFormat,
        ;
    }
    from;
    "./types";
    {
        JSONSchemaType;
    }
    from;
    "./types/json-schema";
    {
        JTDSchemaType;
    }
    from;
    "./types/jtd-schema";
    var validation_error_1 = require("./runtime/validation_error");
    var ref_error_1 = require("./compile/ref_error");
    var rules_1 = require("./compile/rules");
    var compile_1 = require("./compile");
    var codegen_1 = require("./compile/codegen");
    var resolve_1 = require("./compile/resolve");
    var dataType_1 = require("./compile/validate/dataType");
    var util_1 = require("./compile/util");
    var $dataRefSchema = require("./refs/data.json");
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = new Set([
        "validate",
        "serialize",
        "parse",
        "wrapper",
        "root",
        "schema",
        "keyword",
        "pattern",
        "formats",
        "validate$data",
        "func",
        "obj",
        "Error",
    ]);
     & DeprecatedOptions;
        | (function (comment, schemaPath, rootSchema) { return unknown; });
    formats ?  : (_a = {}, _a[Name in string] = Format, _a);
    keywords ?  : Vocabulary;
    schemas ?  : AnySchema[] | (_b = {}, _b[Key in string] = AnySchema, _b);
    logger ?  : Logger | false;
    loadSchema ?  : function (uri) { return Promise < AnySchemaObject >
        // options to modify validated data:
        removeAdditional ?  : boolean | "all" | "failing"; };
    useDefaults ?  : boolean | "empty";
    coerceTypes ?  : boolean | "array";
    // advanced options:
    next ?  : boolean; // NEW
    unevaluated ?  : boolean; // NEW
    dynamicRef ?  : boolean; // NEW
    jtd ?  : boolean; // NEW
    meta ?  : SchemaObject | boolean;
    defaultMeta ?  : string | AnySchemaObject;
    validateSchema ?  : boolean | "log";
    addUsedSchema ?  : boolean;
    inlineRefs ?  : boolean | number;
    passContext ?  : boolean;
    loopRequired ?  : number;
    loopEnum ?  : number; // NEW
    ownProperties ?  : boolean;
    multipleOfPrecision ?  : number;
    messages ?  : boolean;
    code ?  : CodeOptions; // NEW
    "object" | "property";
    nullable ?  : boolean; // "nullable" keyword is supported by default
    jsonPointers ?  : boolean;
    extendRefs ?  : true | "ignore" | "fail";
    missingRefs ?  : true | "ignore" | "fail";
    processCode ?  : function (code, schema) { return string; };
    sourceCode ?  : boolean;
    schemaId ?  : string;
    strictDefaults ?  : boolean;
    strictKeywords ?  : boolean;
    uniqueItems ?  : boolean;
    unknownFormats ?  : true | string[] | "ignore";
    cache ?  : any;
    serialize ?  : function (schema) { return unknown; };
    ajvErrors ?  : boolean;
    T;
    - ?  : string | undefined;
    var removedOptions = {
        errorDataPath: "",
        format: "`validateFormats: false` can be used instead.",
        nullable: '"nullable" keyword is supported by default.',
        jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
        extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
        missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
        processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
        sourceCode: "Use option `code: {source: true}`",
        schemaId: "JSON Schema draft-04 is not supported in Ajv v7/8.",
        strictDefaults: "It is default now, see option `strict`.",
        strictKeywords: "It is default now, see option `strict`.",
        uniqueItems: '"uniqueItems" keyword is always validated.',
        unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
        cache: "Map is used as cache, schema object as key.",
        serialize: "Map is used as cache, schema object as key.",
        ajvErrors: "It is default now, see option `strict`.",
    };
    var deprecatedOptions = {
        ignoreKeywordsWithRef: "",
        jsPropertySyntax: "",
        unicode: '"minLength"/"maxLength" account for unicode characters by default.',
    };
     & { code: InstanceCodeOptions };
     & RequiredInstanceOptions;
    var MAX_EXPRESSION = 200;
    // eslint-disable-next-line complexity
    function requiredOptions(o) {
        var s = o.strict;
        var _optz = o.code ? .optimize
            :
        ;
        var optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
        return {
            strictSchema: o.strictSchema ?  ? s ?  ? true :  :  :  : ,
            strictNumbers: o.strictNumbers ?  ? s ?  ? true :  :  :  : ,
            strictTypes: o.strictTypes ?  ? s ?  ? "log" :  :  :  : ,
            strictTuples: o.strictTuples ?  ? s ?  ? "log" :  :  :  : ,
            strictRequired: o.strictRequired ?  ? s ?  ? false :  :  :  : ,
            code: o.code ? { o: .code, optimize: optimize } : { optimize: optimize },
            loopRequired: o.loopRequired ?  ? MAX_EXPRESSION :  : ,
            loopEnum: o.loopEnum ?  ? MAX_EXPRESSION :  : ,
            meta: o.meta ?  ? true :  : ,
            messages: o.messages ?  ? true :  : ,
            inlineRefs: o.inlineRefs ?  ? true :  : ,
            addUsedSchema: o.addUsedSchema ?  ? true :  : ,
            validateSchema: o.validateSchema ?  ? true :  : ,
            validateFormats: o.validateFormats ?  ? true :  : ,
            unicodeRegExp: o.unicodeRegExp ?  ? true :  : ,
        };
    }
    var Ajv = (function () {
        function Ajv() {
            this.errors = null; // errors from the last validation
            // shared external scope values for compiled functions
            this.readonly = scope;
            this.readonly = schemas;
        }
        return Ajv;
    })();
    exports.default = Ajv;
    {
        [Key in string] ?  : compile_1.SchemaEnv;
    }
    { }
    readonly;
    refs: {
        [Ref in string] ?  : compile_1.SchemaEnv | string;
    }
    { }
    readonly;
    formats: {
        [Name in string] ?  : AddedFormat;
    }
    { }
    readonly;
    RULES: ValidationRules;
    readonly;
    _compilations: Set < compile_1.SchemaEnv > ;
    new Set();
    readonly;
    _loading: {
        [Ref in string] ?  : Promise();
    }
    { }
    readonly;
    _cache: Map < AnySchema, compile_1.SchemaEnv > ;
    new Map();
    readonly;
    _metaOpts: InstanceOptions;
    validation_error_1.default = validation_error_1.default;
    ref_error_1.default = ref_error_1.default;
    constructor(opts, Options = {});
    {
        opts = this.opts = { opts: opts, requiredOptions: function (opts) { } };
        var _c = this.opts.code, es5 = _c.es5, lines = _c.lines;
        this.scope = new codegen_1.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5: es5, lines: lines });
        this.logger = getLogger(opts.logger);
        var formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = rules_1.getRules();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
            addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
            addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
            this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
    }
    _addVocabularies();
    void {
        this: .addKeyword("$async")
    };
    _addDefaultMetaSchema();
    void {
        const: (_d = this.opts, $data = _d.$data, meta = _d.meta, _d),
        if: function (meta) {
            if (meta === void 0) { meta =  && $data; }
        }, this: .addMetaSchema($dataRefSchema, $dataRefSchema.$id, false)
    };
    defaultMeta();
    string | AnySchemaObject | undefined;
    {
        var meta = this.opts.meta;
        return (this.opts.defaultMeta = typeof meta == "object" ? meta.$id || meta : undefined);
    }
    // Validate data using schema
    // AnySchema will be compiled and cached using schema itself as a key for Map
    validate(schema, Schema | string, data, unknown);
    boolean;
    validate(schemaKeyRef, AnySchema | string, data, unknown);
    boolean | Promise < unknown >
        validate(schema, Schema | JSONSchemaType( | string, data, unknown), data, is, T, 
        // Separated for type inference to work
        // eslint-disable-next-line @typescript-eslint/unified-signatures
        validate(schema, JTDSchemaType < T > , data, unknown), data, is, T, validate(schema, AsyncSchema, data, unknown | T), Promise < T >
            validate(schemaKeyRef, AnySchema | string, data, unknown), data, is, T | Promise < T >
            validate(schemaKeyRef, AnySchema | string, data, unknown | T // to be validated
            ), boolean | Promise < T > {
            let: v, AnyValidateFunction:  | undefined,
            if: function () { }, typeof: schemaKeyRef == "string" });
    {
        v = this.getSchema(schemaKeyRef);
        if (!v)
            throw new Error("no schema with key or ref \"" + schemaKeyRef + "\"");
    }
    {
        v = this.compile(schemaKeyRef);
    }
    var valid = v(data);
    if (!("$async" in v))
        this.errors = v.errors;
    return valid;
    // Create validation function for passed schema
    // _meta: true if schema is a meta-schema. Used internally to compile meta schemas of user-defined keywords.
    compile(schema, Schema | JSONSchemaType < T > , _meta ?  : boolean);
    ValidateFunction < T >
        // Separated for type inference to work
        // eslint-disable-next-line @typescript-eslint/unified-signatures
        compile(schema, JTDSchemaType < T > , _meta ?  : boolean);
    ValidateFunction < T >
        compile(schema, AsyncSchema, _meta ?  : boolean);
    AsyncValidateFunction < T >
        compile(schema, AnySchema, _meta ?  : boolean);
    AnyValidateFunction < T >
        compile(schema, AnySchema, _meta ?  : boolean);
    AnyValidateFunction < T > {
        const: sch = this._addSchema(schema, _meta),
        return: function (sch, validate) {
            if (validate === void 0) { validate =  || this._compileSchemaEnv(sch); }
        }, as: AnyValidateFunction()
    };
    // Creates validating function for passed schema with asynchronous loading of missing schemas.
    // `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
    // TODO allow passing schema URI
    // meta - optional true to compile meta-schema
    compileAsync(schema, SchemaObject | JSONSchemaType < T > , _meta ?  : boolean);
    Promise < ValidateFunction < T >>
        // Separated for type inference to work
        // eslint-disable-next-line @typescript-eslint/unified-signatures
        compileAsync(schema, JTDSchemaType < T > , _meta ?  : boolean);
    Promise < ValidateFunction < T >>
        compileAsync(schema, AsyncSchema, meta ?  : boolean);
    Promise < AsyncValidateFunction < T >>
        // eslint-disable-next-line @typescript-eslint/unified-signatures
        compileAsync(schema, AnySchemaObject, meta ?  : boolean);
    Promise < AnyValidateFunction < T >>
        compileAsync(schema, AnySchemaObject, meta ?  : boolean);
    Promise < AnyValidateFunction < T >> {
        if: function () { }, typeof: this.opts.loadSchema != "function" };
    {
        throw new Error("options.loadSchema should be a function");
    }
    var loadSchema = this.opts.loadSchema;
    return runCompileAsync.call(this, schema, meta);
    async;
    this;
    Ajv,
        _schema;
    AnySchemaObject,
        _meta ?  : boolean;
    Promise < AnyValidateFunction > {
        await: loadMetaSchema.call(this, _schema.$schema),
        const: sch = this._addSchema(_schema, _meta),
        return: sch.validate || _compileAsync.call(this, sch)
    };
    async;
    this;
    Ajv, $ref ?  : string;
    Promise < void  > {
        if: function ($ref) {
            if ($ref === void 0) { $ref =  && !this.getSchema($ref); }
            await;
            runCompileAsync.call(this, { $ref: $ref }, true);
        }
    };
    async;
    this;
    Ajv, sch;
    compile_1.SchemaEnv;
    Promise < AnyValidateFunction > {
        try: {
            return: this._compileSchemaEnv(sch)
        }, catch: function (e) {
            if (!(e instanceof ref_error_1.default))
                throw e;
            checkLoaded.call(this, e);
            await;
            loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
        }
    };
    this;
    Ajv, { missingSchema: ref, missingRef: missingRef };
    ref_error_1.default;
    void {
        if: function () { }, this: .refs[ref] };
    {
        throw new Error("AnySchema " + ref + " is loaded but " + missingRef + " cannot be resolved");
    }
    async;
    this;
    Ajv, ref;
    string;
    Promise < void  > {
        const: _schema = await, _loadSchema: .call(this, ref),
        if: function () { } };
    !this.refs[ref];
    await;
    loadMetaSchema.call(this, _schema.$schema);
    if (!this.refs[ref])
        this.addSchema(_schema, ref, meta);
    async;
    this;
    Ajv, ref;
    string;
    Promise < AnySchemaObject > {
        const: p = this._loading[ref],
        if: function (p) { }, return: p,
        try: {
            return: await(this._loading[ref] = loadSchema(ref))
        }, finally: {
            delete: this._loading[ref]
        }
    };
    // Adds schema to the instance
    addSchema(schema, AnySchema | AnySchema[], key ?  : string, _meta ?  : boolean, _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
    );
    Ajv;
    {
        if (Array.isArray(schema)) {
            for (var _i = 0; _i < schema.length; _i++) {
                var sch = schema[_i];
                this.addSchema(sch, undefined, _meta, _validateSchema);
            }
            return this;
        }
        var id;
        if (typeof schema === "object") {
            id = schema.$id;
            if (id !== undefined && typeof id != "string")
                throw new Error("schema $id must be string");
        }
        key = resolve_1.normalizeId(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(schema, AnySchemaObject, key ?  : string, _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
    );
    Ajv;
    {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
    }
    //  Validate schema against its meta-schema
    validateSchema(schema, AnySchema, throwOrLogError ?  : boolean);
    boolean | Promise < unknown > {
        if: function () { }, typeof: schema == "boolean", return: true,
        let: $schema, string:  | AnySchemaObject | undefined,
        $schema:  = schema.$schema,
        if: function ($schema) {
            if ($schema === void 0) { $schema =  !== undefined && typeof $schema != "string"; }
            throw new Error("$schema must be a string");
        },
        $schema:  = $schema || this.opts.defaultMeta || this.defaultMeta(),
        if: function () { } };
    !$schema;
    {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
    }
    var valid = this.validate($schema, schema);
    if (!valid && throwOrLogError) {
        var message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
            this.logger.error(message);
        else
            throw new Error(message);
    }
    return valid;
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(keyRef, string);
    AnyValidateFunction( | undefined, {
        let: sch,
        while: function () { }, typeof: function (sch) {
            if (sch === void 0) { sch = getSchEnv.call(this, keyRef); }
        } } == "string");
    keyRef = sch;
    if (sch === undefined) {
        var root = new compile_1.SchemaEnv({ schema: {} });
        sch = compile_1.resolveSchema.call(this, root, keyRef);
        if (!sch)
            return;
        this.refs[keyRef] = sch;
    }
    return (sch.validate || this._compileSchemaEnv(sch));
    as;
    AnyValidateFunction( | undefined, 
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(schemaKeyRef ?  : AnySchema | string | RegExp), Ajv, {
        if: function (schemaKeyRef) {
            if (schemaKeyRef === void 0) { schemaKeyRef =  instanceof RegExp; }
            this._removeAllSchemas(this.schemas, schemaKeyRef);
            this._removeAllSchemas(this.refs, schemaKeyRef);
            return this;
        },
        switch: function () { }, typeof: schemaKeyRef });
    {
        "undefined";
        this._removeAllSchemas(this.schemas);
        this._removeAllSchemas(this.refs);
        this._cache.clear();
        return this;
        "string";
        {
            var sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
                this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
        }
        "object";
        {
            var cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            var id = schemaKeyRef.$id;
            if (id) {
                id = resolve_1.normalizeId(id);
                delete this.schemas[id];
                delete this.refs[id];
            }
            return this;
        }
        throw new Error("ajv.removeSchema: invalid parameter");
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(definitions, Vocabulary);
    Ajv;
    {
        for (var _e = 0; _e < definitions.length; _e++) {
            var def = definitions[_e];
            this.addKeyword(def);
        }
        return this;
    }
    addKeyword(kwdOrDef, string | KeywordDefinition, def ?  : KeywordDefinition // deprecated
    );
    Ajv;
    {
        var keyword;
        if (typeof kwdOrDef == "string") {
            keyword = kwdOrDef;
            if (typeof def == "object") {
                this.logger.warn("these parameters are deprecated, see docs for addKeyword");
                def.keyword = keyword;
            }
        }
        else if (typeof kwdOrDef == "object" && def === undefined) {
            def = kwdOrDef;
            keyword = def.keyword;
            if (Array.isArray(keyword) && !keyword.length) {
                throw new Error("addKeywords: keyword must be string or non-empty array");
            }
        }
        else {
            throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
            util_1.eachItem(keyword, function (kwd) { return addRule.call(_this, kwd); });
            return this;
        }
        keywordMetaschema.call(this, def);
        var definition = {};
        def,
            type;
        dataType_1.getJSONTypes(def.type),
            schemaType;
        dataType_1.getJSONTypes(def.schemaType),
        ;
    }
    util_1.eachItem(keyword, definition.type.length === 0
        ? function (k) { return addRule.call(_this, k, definition); }
        : function (k) { return definition.type.forEach(function (t) { return addRule.call(_this, k, definition, t); }); });
    return this;
    getKeyword(keyword, string);
    AddedKeywordDefinition | boolean;
    {
        var rule_1 = this.RULES.all[keyword];
        return typeof rule_1 == "object" ? rule_1.definition : !!rule_1;
    }
    // Remove keyword
    removeKeyword(keyword, string);
    Ajv;
    {
        // TODO return type should be Ajv
        var RULES = this.RULES;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (var _f = 0, _g = RULES.rules; _f < _g.length; _f++) {
            var group = _g[_f];
            var i = group.rules.findIndex(function (rule) { return rule.keyword === keyword; });
            if (i >= 0)
                group.rules.splice(i, 1);
        }
        return this;
    }
    // Add format
    addFormat(name, string, format, Format);
    Ajv;
    {
        if (typeof format == "string")
            format = new RegExp(format);
        this.formats[name] = format;
        return this;
    }
    errorsText(errors, ErrorObject[] | null | undefined, this.errors, { separator:  = ", ", dataVar:  = "data" }, ErrorsTextOptions = {} // optional options with properties `separator` and `dataVar`
    );
    string;
    {
        if (!errors || errors.length === 0)
            return "No errors";
        return errors
            .map(function (e) { return ("" + dataVar + e.instancePath + " " + e.message); })
            .reduce(function (text, msg) { return text + separator + msg; });
    }
    $dataMetaSchema(metaSchema, AnySchemaObject, keywordsJsonPointers, string[]);
    AnySchemaObject;
    {
        var rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (var _h = 0; _h < keywordsJsonPointers.length; _h++) {
            var jsonPointer = keywordsJsonPointers[_h];
            var segments = jsonPointer.split("/").slice(1); // first segment is an empty string
            var keywords = metaSchema;
            for (var _j = 0; _j < segments.length; _j++) {
                var seg = segments[_j];
                keywords = keywords[seg];
            }
            as;
            AnySchemaObject;
            for (var key in rules) {
                var rule_2 = rules[key];
                if (typeof rule_2 != "object")
                    continue;
                var $data = rule_2.definition.$data;
                var schema = keywords[key], as = AnySchemaObject | undefined;
                if ($data && schema)
                    keywords[key] = schemaOrData(schema);
            }
        }
        return metaSchema;
    }
    _removeAllSchemas(schemas, (_k = {}, _k[Ref in string] = compile_1.SchemaEnv | string, _k), regex ?  : RegExp);
    void {
        for: function () {
            if ( === void 0) {  = keyRef in schemas; }
            var sch = schemas[keyRef];
            if (!regex || regex.test(keyRef)) {
                if (typeof sch == "string") {
                    delete schemas[keyRef];
                }
                else if (sch && !sch.meta) {
                    this._cache.delete(sch.schema);
                    delete schemas[keyRef];
                }
            }
        }
    };
    _addSchema(schema, AnySchema, meta ?  : boolean, baseId ?  : string, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema);
    compile_1.SchemaEnv;
    {
        var id;
        if (typeof schema == "object") {
            id = schema.$id;
        }
        else {
            if (this.opts.jtd)
                throw new Error("schema must be object");
            else if (typeof schema != "boolean")
                throw new Error("schema must be object or boolean");
        }
        var sch = this._cache.get(schema);
        if (sch !== undefined)
            return sch;
        var localRefs = resolve_1.getSchemaRefs.call(this, schema);
        baseId = resolve_1.normalizeId(id || baseId);
        sch = new compile_1.SchemaEnv({ schema: schema, meta: meta, baseId: baseId, localRefs: localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
            if (baseId)
                this._checkUnique(baseId);
            this.refs[baseId] = sch;
        }
        if (validateSchema)
            this.validateSchema(schema, true);
        return sch;
    }
    _checkUnique(id, string);
    void {
        if: function () { }, this: .schemas[id] || this.refs[id] };
    {
        throw new Error("schema with key or id \"" + id + "\" already exists");
    }
    _compileSchemaEnv(sch, compile_1.SchemaEnv);
    AnyValidateFunction;
    {
        if (sch.meta)
            this._compileMetaSchema(sch);
        else
            compile_1.compileSchema.call(this, sch);
        /* istanbul ignore if */
        if (!sch.validate)
            throw new Error("ajv implementation error");
        return sch.validate;
    }
    _compileMetaSchema(sch, compile_1.SchemaEnv);
    void {
        const: currentOpts = this.opts,
        this: .opts = this._metaOpts,
        try: {
            compileSchema: .call(this, sch)
        }, finally: {
            this: .opts = currentOpts
        }
    };
    this;
    Ajv,
        checkOpts;
    OptionsInfo < RemovedOptions | DeprecatedOptions > ,
        options;
    Options & RemovedOptions,
        msg;
    string,
        log;
    "warn" | "error";
    "error";
    void {
        for: function () {
            if ( === void 0) {  = key in checkOpts; }
            var opt = key, as = keyof;
            typeof checkOpts;
            if (opt in options)
                this.logger[log](msg + ": option " + key + ". " + checkOpts[opt]);
        }
    };
    this;
    Ajv, keyRef;
    string;
    compile_1.SchemaEnv | string | undefined;
    {
        keyRef = resolve_1.normalizeId(keyRef); // TODO tests fail without this line
        return this.schemas[keyRef] || this.refs[keyRef];
    }
    this;
    Ajv;
    void {
        const: optsSchemas = this.opts.schemas,
        if: function () { } };
    !optsSchemas;
    return;
    if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
    else
        for (var key in optsSchemas)
            this.addSchema(optsSchemas[key], as, AnySchema, key);
    this;
    Ajv;
    void {
        for: function () {
            if ( === void 0) {  = name in this.opts.formats; }
            var format = this.opts.formats[name];
            if (format)
                this.addFormat(name, format);
        }
    };
    this;
    Ajv,
        defs;
    Vocabulary | (_l = {}, _l[K in string] = KeywordDefinition, _l);
    void {
        if: function (Array, isArray) {
            if (isArray === void 0) { isArray = (defs); }
            this.addVocabulary(defs);
            return;
        },
        this: .logger.warn("keywords option as map is deprecated, pass array"),
        for: function () {
            if ( === void 0) {  = keyword in defs; }
            var def = defs[keyword], as = KeywordDefinition;
            if (!def.keyword)
                def.keyword = keyword;
            this.addKeyword(def);
        }
    };
    this;
    Ajv;
    InstanceOptions;
    {
        var metaOpts = { this: .opts };
        for (var _m = 0; _m < META_IGNORE_OPTIONS.length; _m++) {
            var opt = META_IGNORE_OPTIONS[_m];
            delete metaOpts[opt];
        }
        return metaOpts;
    }
    var noLogs = { log: function () { }, warn: function () { }, error: function () { } };
    function getLogger(logger) {
        if (logger === void 0) { logger = false; }
        if (logger === false)
            return noLogs;
        if (logger === undefined)
            return console;
        if (logger.log && logger.warn && logger.error)
            return logger;
        as;
        Logger;
        throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    this;
    Ajv, keyword;
    string | string[], def ?  : KeywordDefinition;
    void {
        const: (_o = this, RULES = _o.RULES, _o),
        eachItem: function (keyword) { } }(kwd);
    {
        if (RULES.keywords[kwd])
            throw new Error("Keyword " + kwd + " is already defined");
        if (!KEYWORD_NAME.test(kwd))
            throw new Error("Keyword " + kwd + " has invalid name");
    }
    if (!def)
        return;
    if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
    }
    this;
    Ajv,
        keyword;
    string,
        definition ?  : AddedKeywordDefinition,
        dataType ?  : JSONType;
    void {
        const: post = definition ? .post
            :
        ,
        if: function (dataType) {
            if (dataType === void 0) { dataType =  && post; }
        }, throw: new Error('keyword with "post" flag cannot have "type"'),
        const: (_p = this, RULES = _p.RULES, _p),
        let: ruleGroup = post ? RULES.post : RULES.rules.find(function (_a) {
            var t = _a.type;
            return t === dataType;
        }),
        if: function () { } };
    !ruleGroup;
    {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword] = true;
    if (!definition)
        return;
    var rule = {
        keyword: keyword,
        definition: {} };
    definition,
        type;
    dataType_1.getJSONTypes(definition.type),
        schemaType;
    dataType_1.getJSONTypes(definition.schemaType),
    ;
    if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
        ruleGroup.rules.push(rule);
    RULES.all[keyword] = rule;
    definition.implements ? .forEach(function (kwd) { return _this.addKeyword(kwd); })
        :
    ;
    this;
    Ajv, ruleGroup;
    RuleGroup, rule;
    Rule, before;
    string;
    void {
        const: i = ruleGroup.rules.findIndex(function (_rule) { return _rule.keyword === before; }),
        if: function (i) {
            if (i === void 0) { i =  >= 0; }
            ruleGroup.rules.splice(i, 0, rule);
        }, else: {
            ruleGroup: .rules.push(rule),
            this: .logger.warn("rule " + before + " is not defined")
        }
    };
    this;
    Ajv, def;
    KeywordDefinition;
    void {
        let: (metaSchema = def.metaSchema, def),
        if: function (metaSchema) {
            if (metaSchema === void 0) { metaSchema =  === undefined; }
        }, return: ,
        if: function (def, $data) {
            if ($data === void 0) { $data =  && this.opts.$data; }
        }, metaSchema:  = schemaOrData(metaSchema),
        def: .validateSchema = this.compile(metaSchema, true)
    };
    var $dataRef = {
        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    };
    function schemaOrData(schema) {
        return { anyOf: [schema, $dataRef] };
    }
    var _a, _b, _d, _k, _l, _o, _p;
});
