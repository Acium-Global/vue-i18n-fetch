var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "./core", "./vocabularies/jtd", "./refs/jtd-schema", "./compile/jtd/serialize", "./compile/jtd/parse", "./compile"], function (require, exports) {
    {
        AnySchemaObject, SchemaObject, JTDParser;
    }
    from;
    "./types";
    {
        JTDSchemaType, JTDDataType;
    }
    from;
    "./types/jtd-schema";
    var core_1 = require("./core");
    var jtd_1 = require("./vocabularies/jtd");
    var jtd_schema_1 = require("./refs/jtd-schema");
    var serialize_1 = require("./compile/jtd/serialize");
    var parse_1 = require("./compile/jtd/parse");
    var compile_1 = require("./compile");
    var META_SCHEMA_ID = "JTD-meta-schema";
     & {
        // strict mode options not supported with JTD:
        strict: never,
        allowMatchingProperties: never,
        allowUnionTypes: never,
        validateFormats: never,
        // validation and reporting options not supported with JTD:
        $data: never,
        verbose: boolean,
        $comment: never,
        formats: never,
        loadSchema: never,
        // options to modify validated data:
        useDefaults: never,
        coerceTypes: never,
        // advanced options:
        next: never,
        unevaluated: never,
        dynamicRef: never,
        meta: boolean,
        defaultMeta: never,
        inlineRefs: boolean,
        loopRequired: never,
        multipleOfPrecision: never
    };
    var Ajv = (function (_super) {
        __extends(Ajv, _super);
        function Ajv(opts) {
            if (opts === void 0) { opts = {}; }
            _super.apply(this, [{}].concat(opts, [jtd, true]));
        }
        return Ajv;
    })(core_1.default);
    _addVocabularies();
    void {
        super: ._addVocabularies(),
        this: .addVocabulary(jtd_1.default)
    };
    _addDefaultMetaSchema();
    void {
        super: ._addDefaultMetaSchema(),
        if: function () { } };
    !this.opts.meta;
    return;
    this.addMetaSchema(jtd_schema_1.default, META_SCHEMA_ID, false);
    defaultMeta();
    string | AnySchemaObject | undefined;
    {
        return (this.opts.defaultMeta =
            _super.defaultMeta.call(this) || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
    }
    serialize_1.default(schema, SchemaObject);
    (function (data) { return string; });
    // Separated for type inference to work
    // eslint-disable-next-line @typescript-eslint/unified-signatures
    serialize_1.default(schema, JTDSchemaType(), function (data) { return string; }, serialize_1.default(schema, SchemaObject), function (data) { return string; }, {
        const: sch = this._addSchema(schema),
        return: sch.serialize || this._compileSerializer(sch)
    }, parse_1.default(schema, SchemaObject), JTDParser < T >
        // Separated for type inference to work
        // eslint-disable-next-line @typescript-eslint/unified-signatures
        parse_1.default(schema, JTDSchemaType(), JTDParser < T >
            parse_1.default(schema, SchemaObject), JTDParser < T > {
            const: sch = this._addSchema(schema),
            return: function (sch, parse) {
                if (parse === void 0) { parse =  || this._compileParser(sch); }
            }, as: JTDParser()
        }, private, _compileSerializer(sch, compile_1.SchemaEnv), function (data) { return string; }, {
            compileSerializer: .call(this, sch, (sch.schema), as, AnySchemaObject).definitions || {} }));
    /* istanbul ignore if */
    if (!sch.serialize)
        throw new Error("ajv implementation error");
    return sch.serialize;
    _compileParser(sch, compile_1.SchemaEnv);
    JTDParser;
    {
        parse_1.default.call(this, sch, (sch.schema), as, AnySchemaObject).definitions || {};
        /* istanbul ignore if */
        if (!sch.parse)
            throw new Error("ajv implementation error");
        return sch.parse;
    }
    module.exports = exports = Ajv;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv;
});
