(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "../compile/codegen/scope", "../compile/codegen/code"], function (require, exports) {
    from;
    "../core";
    {
        AnyValidateFunction, SourceCode;
    }
    from;
    "../types";
    {
        SchemaEnv;
    }
    from;
    "../compile";
    var scope_1 = require("../compile/codegen/scope");
    var code_1 = require("../compile/codegen/code");
    function standaloneCode(ajv, refsOrFunc) {
        if (!ajv.opts.code.source) {
            throw new Error("moduleCode: ajv instance must have code.source option");
        }
        var _n = ajv.scope.opts._n;
        return typeof refsOrFunc == "function"
            ? funcExportCode(refsOrFunc.source)
            : refsOrFunc !== undefined
                ? multiExportsCode(refsOrFunc, getValidate)
                : multiExportsCode(ajv.schemas, function (sch) {
                    return sch.meta ? undefined : ajv.compile(sch.schema);
                });
        function getValidate(id) {
            var v = ajv.getSchema(id);
            if (!v)
                throw new Error("moduleCode: no schema with id " + id);
            return v;
        }
        function funcExportCode(source) {
            var usedValues = {};
            var n = source ? .validateName
                :
            ;
            var vCode = validateCode(usedValues, source);
            return "\"use strict\";" + _n + "module.exports = " + n + ";" + _n + "module.exports.default = " + n + ";" + _n + vCode;
        }
        function multiExportsCode(schemas, getValidateFunc) {
            var usedValues = {};
            var code = (_a = ["\"use strict\";"], _a.raw = ["\"use strict\";"], code_1._(_a));
            for (var name_1 in schemas) {
                var v = getValidateFunc(schemas[name_1], as, T);
                if (v) {
                    var vCode = validateCode(usedValues, v.source);
                    code = (_b = ["", "", "exports", " = ", ";", "", ""], _b.raw = ["", "", "exports", " = ", ";", "", ""], code_1._(_b, code, _n, code_1.getProperty(name_1), v.source ? .validateName : , _n, vCode));
                }
            }
            return "" + code;
            var _a, _b;
        }
        function validateCode(usedValues, s) {
            if (!s)
                throw new Error('moduleCode: function does not have "source" property');
            if (usedState(s.validateName) === scope_1.UsedValueState.Completed)
                return code_1.nil;
            setUsedState(s.validateName, scope_1.UsedValueState.Started);
            var scopeCode = ajv.scope.scopeCode(s.scopeValues, usedValues, refValidateCode);
            var code = new code_1._Code("" + scopeCode + _n + s.validateCode);
            return s.evaluated ? (_a = ["", "", ".evaluated = ", ";", ""], _a.raw = ["", "", ".evaluated = ", ";", ""], code_1._(_a, code, s.validateName, s.evaluated, _n)) : code;
            function refValidateCode(n) {
                var vRef = n.value ? .ref
                    :
                ;
                if (n.prefix === "validate" && typeof vRef == "function") {
                    var v = vRef, as = AnyValidateFunction;
                    return validateCode(usedValues, v.source);
                }
                else if ((n.prefix === "root" || n.prefix === "wrapper") && typeof vRef == "object") {
                    var validate = vRef.validate, validateName = vRef.validateName, as = SchemaEnv;
                    if (!validateName)
                        throw new Error("ajv internal error");
                    var def = ajv.opts.code.es5 ? scope_1.varKinds.var : scope_1.varKinds.const;
                    var wrapper = (_a = ["", " ", " = {validate: ", "};"], _a.raw = ["", " ", " = {validate: ", "};"], code_1._(_a, def, n, validateName));
                    if (usedState(validateName) === scope_1.UsedValueState.Started)
                        return wrapper;
                    var vCode = validateCode(usedValues, validate ? .source : );
                    return (_b = ["", "", "", ""], _b.raw = ["", "", "", ""], code_1._(_b, wrapper, _n, vCode));
                }
                return undefined;
                var _a, _b;
            }
            function usedState(name) {
                return usedValues[name.prefix] ? .get(name)
                    :
                ;
            }
            function setUsedState(name, state) {
                var prefix = name.prefix;
                var names = (usedValues[prefix] = usedValues[prefix] || new Map());
                names.set(name, state);
            }
            var _a;
        }
    }
    exports.default = standaloneCode;
});
