(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports"], function (require, exports) {
    T;
    - ?  : undefined;
    T[K] ? never : K;
    [keyof, T];
    T;
    - ?  : undefined;
    T[K] ? K : never;
    [keyof, T];
    false;
    (T);
    unknown ? ([U]) : ;
    [T] ? false : true;
    never;
    false;
    true;
    [E] ? ([E]) : ;
    [T] ? true : false;
    false;
    null, E | null >
        /** gets only the string literals of a type or null if a type isn't a string literal */
        type;
    EnumString < T > ;
    [T];
    [never]
        ? null
        : T;
    string
        ? string : ;
    T
        ? null
        : T;
    null;
    null;
    EnumString < Exclude < T, null >>  ? false : true;
    false;
    IsUnion([T], [readonly, unknown[]]
        ? undefined : , T[0.5]
        ? false
        : true, false, false, 
    /** true if the the type is a values type */
    type, IsValues < T > , false, IsUnion < Exclude < T, null >>
        ? TypeEquality < keyof : Exclude < T, null > , string >
    , false, 
    /** true if type is a proeprties type and Union is false, or type is a discriminator type and Union is true */
    type, IsRecord < T, Union, boolean > , Union, IsUnion < Exclude < T, null >>
        ? null : , EnumString < keyof, Exclude < T, null >>
        ? false
        : true, false, 
    /** numeric strings */
    type, NumberType = "float32" | "float64" | "int8" | "uint8" | "int16" | "uint16" | "int32" | "uint32", 
    /** string strings */
    type, StringType = "string" | "timestamp");
     > ;
    (
        |
            (null));
    EnumString(never, 
        | ((_a = {}, _a[K in keyof] = D, _a[T] = , _a.extends = [D[K]] ? { ref: K } : never, _a)[keyof]), D,  & { nullable: false })
        | (null);
    T
        ? (_b = {},
            _b[K in keyof] = D,
            _b[Exclude < T, null > ] = ,
            _b.extends = [Exclude < D[K], null > ]
                ? { ref: K }
                : never,
            _b
        )[keyof] : D;
     & { nullable: true };
    never;
    // empty - empty schemas also treat nullable differently in that it's now fully ignored
        | (unknown);
    T ? { nullable: boolean } : never;
    // all other types
        | ((true));
    NullTypeEquality({ type: NumberType }, true, NullTypeEquality({ type: "boolean" }, true, NullTypeEquality({ type: StringType }, true, NullTypeEquality({ type: "timestamp" }, 
    // TODO we can't actually check that everything in the union was specified
    true, IsEnum({ enum: EnumString < Exclude < T, null:  >> [] }, true, IsElements < Exclude < T, null >>
        ? T : , readonly(infer, E)[]
        ? {
            elements: JTDSchemaType()
        }
        : never, true, IsValues(T, Record({
        values: JTDSchemaType()
    }, never, true, IsRecord < T, false >
        ? ([RequiredKeys < Exclude < T, null >> ]) : , [never]
        ? {
            properties: Record()
        }
        : {
            properties: (_c = {}, _c[K in RequiredKeys(JTDSchemaType())] = , _c)
        }) &
        ([OptionalKeys < Exclude < T, null >> ]), [never]
        ? {
            optionalProperties: Record()
        }
        : {
            optionalProperties: (_d = {},
                _d[K in OptionalKeys(JTDSchemaType())] = ,
                _d
            )
        }) & {
        additionalProperties: boolean
    }, true, IsRecord < T, true >
        ? (_e = {},
            _e[K in keyof] = Exclude < T,
            _e.null =  > ,
            _e
        ) -  ?  : Exclude < T : , null > [K], string
        ? {
            discriminator: K,
            mapping: (_f = {},
                // TODO currently allows descriminator to be present in schema
                _f[M in Exclude < T, null > [K]] = JTDSchemaType <
                    Omit < T,
                _f.extends = (_g = {}, _g[C in K] = M, _g) ? T : never,
                _f.K =  > ,
                _f.D = 
                    >
                ,
                _f
            )
        }
        : never, [keyof, Exclude < T, null > ], never) &
        (null), T
        ? {
            nullable: true
        }
        : { nullable: false }))) & {
        // extra properties
        metadata: Record < string, unknown:  >
            // TODO these should only be allowed at the top level
            definitions ?  : (_h = {}, _h[K in keyof] = D, _h.JTDSchemaType = , _h[K] = , _h.D =  > , _h)
    }, type, JTDDataDef < S, D, Record < string, unknown >> , 
        | (S), { ref: string }
        ? JTDDataDef < D[S["ref"]] : , D >
    , S, { type: NumberType }
        ? number
        : S, { type: "string" }
        ? string
        : S, { type: "timestamp" }
        ? string | Date
        :
            S, { enum: readonly(infer, E)[] }
        ? string : , E
        ? never
        : [E], [string]
        ? E
        : never, S, { elements: infer, E: E }
        ? JTDDataDef < E : , D > [], S, {
        properties: Record < string, unknown:  >
            optionalProperties ?  : Record < string, unknown:  >
            additionalProperties ?  : boolean
    }
        ? {} - readonly[K in keyof] : S["properties"], - ?  : JTDDataDef < S["properties"][K], D > ,  &
        {}
            - readonly[K in keyof], S["optionalProperties"], + ?  : JTDDataDef <
        S["optionalProperties"][K], D
        >
    ,  &
        ([S["additionalProperties"]]), [true] ? Record(unknown)
        : S, {
        properties: Record < string, unknown:  >
            optionalProperties, Record: function () { },
        additionalProperties: boolean
    }
        ? {} - readonly[K in keyof] : S["properties"], - ?  : JTDDataDef < S["properties"][K], D > ,  &
        {}
            - readonly[K in keyof], S["optionalProperties"], + ?  : JTDDataDef <
        S["optionalProperties"][K], D
        >
    ,  &
        ([S["additionalProperties"]]), [true] ? Record(unknown)
        :
            S, { values: infer, V: V }
        ? Record(S, { discriminator: infer, M: , mapping: Record() }
            ? [M] : , [string]
            ? (_j = {},
                _j[K in keyof] = S["mapping"],
                _j.JTDDataDef = ,
                _j["mapping"] = [K],
                _j.D =  >  & (_k = {}, _k[KM in M] = K, _k),
                _j
            )[keyof] : S["mapping"], never, unknown)
            | (S) : , { nullable: true } ? null : never);
    {
        definitions: Record();
    }
    JTDDataDef < S, S["definitions"] >
    ;
    JTDDataDef();
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
});
