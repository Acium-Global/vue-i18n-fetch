(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "../../compile/codegen", "../../compile/util"], function (require, exports) {
    {
        CodeKeywordDefinition,
            ErrorObject,
            KeywordErrorDefinition,
            AnySchema,
        ;
    }
    from;
    "../../types";
    {
        SchemaObjCxt;
    }
    from;
    "../../compile";
    {
        KeywordCxt;
    }
    from;
    "../../compile/validate";
    var codegen_1 = require("../../compile/codegen");
    var util_1 = require("../../compile/util");
    "if", { failingKeyword: string }, AnySchema >
    ;
    var error = {
        message: function (_a) {
            var params = _a.params;
            return (_b = ["must match \"", "\" schema"], _b.raw = ["must match \"", "\" schema"], codegen_1.str(_b, params.ifClause));
            var _b;
        },
        params: function (_a) {
            var params = _a.params;
            return (_b = ["{failingKeyword: ", "}"], _b.raw = ["{failingKeyword: ", "}"], codegen_1._(_b, params.ifClause));
            var _b;
        },
    };
    var def = {
        keyword: "if",
        schemaType: ["object", "boolean"],
        trackErrors: true,
        error: error,
        code: function (cxt) {
            var gen = cxt.gen, parentSchema = cxt.parentSchema, it = cxt.it;
            if (parentSchema.then === undefined && parentSchema.else === undefined) {
                util_1.checkStrictMode(it, '"if" without "then" and "else" is ignored');
            }
            var hasThen = hasSchema(it, "then");
            var hasElse = hasSchema(it, "else");
            if (!hasThen && !hasElse)
                return;
            var valid = gen.let("valid", true);
            var schValid = gen.name("_valid");
            validateIf();
            cxt.reset();
            if (hasThen && hasElse) {
                var ifClause = gen.let("ifClause");
                cxt.setParams({ ifClause: ifClause });
                gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
            }
            else if (hasThen) {
                gen.if(schValid, validateClause("then"));
            }
            else {
                gen.if(codegen_1.not(schValid), validateClause("else"));
            }
            cxt.pass(valid, function () { return cxt.error(true); });
            function validateIf() {
                var schCxt = cxt.subschema({
                    keyword: "if",
                    compositeRule: true,
                    createErrors: false,
                    allErrors: false,
                }, schValid);
                cxt.mergeEvaluated(schCxt);
            }
            function validateClause(keyword, ifClause) {
                return function () {
                    var schCxt = cxt.subschema({ keyword: keyword }, schValid);
                    gen.assign(valid, schValid);
                    cxt.mergeValidEvaluated(schCxt, valid);
                    if (ifClause)
                        gen.assign(ifClause, (_a = ["", ""], _a.raw = ["", ""], codegen_1._(_a, keyword)));
                    else
                        cxt.setParams({ ifClause: keyword });
                    var _a;
                };
            }
        },
    };
    function hasSchema(it, keyword) {
        var schema = it.schema[keyword];
        return schema !== undefined && !util_1.alwaysValidSchema(it, schema);
    }
    exports.default = def;
});
