(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "../compile/codegen", "../compile/util", "../compile/names"], function (require, exports) {
    {
        AnySchema, SchemaMap;
    }
    from;
    "../types";
    {
        SchemaCxt;
    }
    from;
    "../compile";
    {
        KeywordCxt;
    }
    from;
    "../compile/validate";
    var codegen_1 = require("../compile/codegen");
    var util_1 = require("../compile/util");
    var names_1 = require("../compile/names");
    function checkReportMissingProp(cxt, prop) {
        var gen = cxt.gen, data = cxt.data, it = cxt.it;
        gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), function () {
            cxt.setParams({ missingProperty: (_a = ["", ""], _a.raw = ["", ""], codegen_1._(_a, prop)) }, true);
            cxt.error();
            var _a;
        });
    }
    exports.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp(_a, properties, missing) {
        var gen = _a.gen, data = _a.data, opts = _a.it.opts;
        return codegen_1.or.apply(void 0, properties.map(function (prop) {
            return codegen_1.and(noPropertyInData(gen, data, prop, opts.ownProperties), (_a = ["", " = ", ""], _a.raw = ["", " = ", ""], codegen_1._(_a, missing, prop)));
            var _a;
        }));
    }
    exports.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
        cxt.setParams({ missingProperty: missing }, true);
        cxt.error();
    }
    exports.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
        return gen.scopeValue("func", {
            // eslint-disable-next-line @typescript-eslint/unbound-method
            ref: Object.prototype.hasOwnProperty,
            code: (_a = ["Object.prototype.hasOwnProperty"], _a.raw = ["Object.prototype.hasOwnProperty"], codegen_1._(_a)),
        });
        var _a;
    }
    exports.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
        return (_a = ["", ".call(", ", ", ")"], _a.raw = ["", ".call(", ", ", ")"], codegen_1._(_a, hasPropFunc(gen), data, property));
        var _a;
    }
    exports.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
        var cond = (_a = ["", "", " !== undefined"], _a.raw = ["", "", " !== undefined"], codegen_1._(_a, data, codegen_1.getProperty(property)));
        return ownProperties ? (_b = ["", " && ", ""], _b.raw = ["", " && ", ""], codegen_1._(_b, cond, isOwnProperty(gen, data, property))) : cond;
        var _a, _b;
    }
    exports.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
        var cond = (_a = ["", "", " === undefined"], _a.raw = ["", "", " === undefined"], codegen_1._(_a, data, codegen_1.getProperty(property)));
        return ownProperties ? codegen_1.or(cond, codegen_1.not(isOwnProperty(gen, data, property))) : cond;
        var _a;
    }
    exports.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
        return schemaMap ? Object.keys(schemaMap).filter(function (p) { return p !== "__proto__"; }) : [];
    }
    exports.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
        return allSchemaProperties(schemaMap).filter(function (p) { return !util_1.alwaysValidSchema(it, schemaMap[p], as, AnySchema); });
    }
    exports.schemaProperties = schemaProperties;
    function callValidateCode(_a, func, context, passSchema) {
        var schemaCode = _a.schemaCode, data = _a.data, _b = _a.it, gen = _b.gen, topSchemaRef = _b.topSchemaRef, schemaPath = _b.schemaPath, errorPath = _b.errorPath, it = _a.it;
        var dataAndSchema = passSchema ? (_c = ["", ", ", ", ", "", ""], _c.raw = ["", ", ", ", ", "", ""], codegen_1._(_c, schemaCode, data, topSchemaRef, schemaPath)) : data;
        var valCxt = [
            [names_1.default.instancePath, codegen_1.strConcat(names_1.default.instancePath, errorPath)],
            [names_1.default.parentData, it.parentData],
            [names_1.default.parentDataProperty, it.parentDataProperty],
            [names_1.default.rootData, names_1.default.rootData],
        ];
        if (it.opts.dynamicRef)
            valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
        var args = (_d = ["", ", ", ""], _d.raw = ["", ", ", ""], codegen_1._(_d, dataAndSchema, gen.object.apply(gen, valCxt)));
        return context !== codegen_1.nil ? (_e = ["", ".call(", ", ", ")"], _e.raw = ["", ".call(", ", ", ")"], codegen_1._(_e, func, context, args)) : (_f = ["", "(", ")"], _f.raw = ["", "(", ")"], codegen_1._(_f, func, args));
        var _c, _d, _e, _f;
    }
    exports.callValidateCode = callValidateCode;
    function usePattern(_a, pattern) {
        var gen = _a.gen, opts = _a.it.opts;
        var u = opts.unicodeRegExp ? "u" : "";
        return gen.scopeValue("pattern", {
            key: pattern,
            ref: new RegExp(pattern, u),
            code: (_b = ["new RegExp(", ", ", ")"], _b.raw = ["new RegExp(", ", ", ")"], codegen_1._(_b, pattern, u)),
        });
        var _b;
    }
    exports.usePattern = usePattern;
    function validateArray(cxt) {
        var gen = cxt.gen, data = cxt.data, keyword = cxt.keyword, it = cxt.it;
        var valid = gen.name("valid");
        if (it.allErrors) {
            var validArr = gen.let("valid", true);
            validateItems(function () { return gen.assign(validArr, false); });
            return validArr;
        }
        gen.var(valid, true);
        validateItems(function () { return gen.break(); });
        return valid;
        function validateItems(notValid) {
            var len = gen.const("len", (_a = ["", ".length"], _a.raw = ["", ".length"], codegen_1._(_a, data)));
            gen.forRange("i", 0, len, function (i) {
                cxt.subschema({
                    keyword: keyword,
                    dataProp: i,
                    dataPropType: util_1.Type.Num,
                }, valid);
                gen.if(codegen_1.not(valid), notValid);
            });
            var _a;
        }
    }
    exports.validateArray = validateArray;
    function validateUnion(cxt) {
        var gen = cxt.gen, schema = cxt.schema, keyword = cxt.keyword, it = cxt.it;
        /* istanbul ignore if */
        if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
        var alwaysValid = schema.some(function (sch) { return util_1.alwaysValidSchema(it, sch); });
        if (alwaysValid && !it.opts.unevaluated)
            return;
        var valid = gen.let("valid", false);
        var schValid = gen.name("_valid");
        gen.block(function () {
            return schema.forEach(function (_sch, i) {
                var schCxt = cxt.subschema({
                    keyword: keyword,
                    schemaProp: i,
                    compositeRule: true,
                }, schValid);
                gen.assign(valid, (_a = ["", " || ", ""], _a.raw = ["", " || ", ""], codegen_1._(_a, valid, schValid)));
                var merged = cxt.mergeValidEvaluated(schCxt, schValid);
                // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
                // or if all properties and items were evaluated (it.props === true && it.items === true)
                if (!merged)
                    gen.if(codegen_1.not(valid));
                var _a;
            });
        });
        cxt.result(valid, function () { return cxt.reset(); }, function () { return cxt.error(true); });
    }
    exports.validateUnion = validateUnion;
});
