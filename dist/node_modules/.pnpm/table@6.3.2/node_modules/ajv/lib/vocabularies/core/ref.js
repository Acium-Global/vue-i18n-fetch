(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "../../compile/ref_error", "../code", "../../compile/codegen", "../../compile/names", "../../compile"], function (require, exports) {
    {
        CodeKeywordDefinition, AnySchema;
    }
    from;
    "../../types";
    {
        KeywordCxt;
    }
    from;
    "../../compile/validate";
    var ref_error_1 = require("../../compile/ref_error");
    var code_1 = require("../code");
    var codegen_1 = require("../../compile/codegen");
    var names_1 = require("../../compile/names");
    var compile_1 = require("../../compile");
    var def = {
        keyword: "$ref",
        schemaType: "string",
        code: function (cxt) {
            var gen = cxt.gen, $ref = cxt.schema, it = cxt.it;
            var baseId = it.baseId, env = it.schemaEnv, validateName = it.validateName, opts = it.opts, self = it.self;
            var root = env.root;
            if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
                return callRootRef();
            var schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
            if (schOrEnv === undefined)
                throw new ref_error_1.default(baseId, $ref);
            if (schOrEnv instanceof compile_1.SchemaEnv)
                return callValidate(schOrEnv);
            return inlineRefSchema(schOrEnv);
            function callRootRef() {
                if (env === root)
                    return callRef(cxt, validateName, env, env.$async);
                var rootName = gen.scopeValue("root", { ref: root });
                return callRef(cxt, (_a = ["", ".validate"], _a.raw = ["", ".validate"], codegen_1._(_a, rootName)), root, root.$async);
                var _a;
            }
            function callValidate(sch) {
                var v = getValidate(cxt, sch);
                callRef(cxt, v, sch, sch.$async);
            }
            function inlineRefSchema(sch) {
                var schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: codegen_1.stringify(sch) } : { ref: sch });
                var valid = gen.name("valid");
                var schCxt = cxt.subschema({
                    schema: sch,
                    dataTypes: [],
                    schemaPath: codegen_1.nil,
                    topSchemaRef: schName,
                    errSchemaPath: $ref,
                }, valid);
                cxt.mergeEvaluated(schCxt);
                cxt.ok(valid);
            }
        },
    };
    function getValidate(cxt, sch) {
        var gen = cxt.gen;
        return sch.validate
            ? gen.scopeValue("validate", { ref: sch.validate })
            : (_a = ["", ".validate"], _a.raw = ["", ".validate"], codegen_1._(_a, gen.scopeValue("wrapper", { ref: sch })));
        var _a;
    }
    exports.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
        var gen = cxt.gen, it = cxt.it;
        var allErrors = it.allErrors, env = it.schemaEnv, opts = it.opts;
        var passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
        if ($async)
            callAsyncRef();
        else
            callSyncRef();
        function callAsyncRef() {
            if (!env.$async)
                throw new Error("async schema referenced by sync schema");
            var valid = gen.let("valid");
            (_a = [", () => gen.throw(e))\n        addErrorsFrom(e)\n        if (!allErrors) gen.assign(valid, false)\n      }\n    )\n    cxt.ok(valid)\n  }\n\n  function callSyncRef(): void {\n    cxt.result(\n      callValidateCode(cxt, v, passCxt),\n      () => addEvaluatedFrom(v),\n      () => addErrorsFrom(v)\n    )\n  }\n\n  function addErrorsFrom(source: Code): void {\n    const errs = _"], _a.raw = [", () => gen.throw(e))\n        addErrorsFrom(e)\n        if (!allErrors) gen.assign(valid, false)\n      }\n    )\n    cxt.ok(valid)\n  }\n\n  function callSyncRef(): void {\n    cxt.result(\n      callValidateCode(cxt, v, passCxt),\n      () => addEvaluatedFrom(v),\n      () => addErrorsFrom(v)\n    )\n  }\n\n  function addErrorsFrom(source: Code): void {\n    const errs = _"], gen.try(function () {
                gen.code((_a = ["await ", ""], _a.raw = ["await ", ""], codegen_1._(_a, code_1.callValidateCode(cxt, v, passCxt))));
                addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result
                if (!allErrors)
                    gen.assign(valid, true);
                var _a;
            }, function (e) {
                gen.if((_a = ["!(", " instanceof ", ""], _a.raw = ["!(", " instanceof ", ""], codegen_1._(_a, e, it.ValidationError)), as, codegen_1.Name);
                var _a;
            })(_a));
            $;
            {
                source;
            }
            (_b = ["\n    gen.assign(N.vErrors, _"], _b.raw = ["\n    gen.assign(N.vErrors, _"], errors(_b));
            $;
            {
                names_1.default.vErrors;
            }
             === null ? $ : { errs: errs };
            $;
            {
                names_1.default.vErrors;
            }
            (_c = [") // TODO tagged\n    gen.assign(N.errors, _"], _c.raw = [") // TODO tagged\n    gen.assign(N.errors, _"], concat($, { errs: errs })(_c));
            $;
            {
                names_1.default.vErrors;
            }
            (_d = [")\n  }\n\n  function addEvaluatedFrom(source: Code): void {\n    if (!it.opts.unevaluated) return\n    const schEvaluated = sch?.validate?.evaluated\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = mergeEvaluated.props(gen, schEvaluated.props, it.props)\n        }\n      } else {\n        const props = gen.var(\"props\", _"], _d.raw = [")\n  }\n\n  function addEvaluatedFrom(source: Code): void {\n    if (!it.opts.unevaluated) return\n    const schEvaluated = sch?.validate?.evaluated\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = mergeEvaluated.props(gen, schEvaluated.props, it.props)\n        }\n      } else {\n        const props = gen.var(\"props\", _"], length(_d));
            $;
            {
                source;
            }
            (_e = [")\n        it.props = mergeEvaluated.props(gen, props, it.props, Name)\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = mergeEvaluated.items(gen, schEvaluated.items, it.items)\n        }\n      } else {\n        const items = gen.var(\"items\", _"], _e.raw = [")\n        it.props = mergeEvaluated.props(gen, props, it.props, Name)\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = mergeEvaluated.items(gen, schEvaluated.items, it.items)\n        }\n      } else {\n        const items = gen.var(\"items\", _"], evaluated.props(_e));
            $;
            {
                source;
            }
            (_f = [")\n        it.items = mergeEvaluated.items(gen, items, it.items, Name)\n      }\n    }\n  }\n}\n\nexport default def\n"], _f.raw = [")\n        it.items = mergeEvaluated.items(gen, items, it.items, Name)\n      }\n    }\n  }\n}\n\nexport default def"], evaluated.items(_f));
            var _a, _b, _c, _d, _e, _f;
        }
    }
    exports.callRef = callRef;
});
