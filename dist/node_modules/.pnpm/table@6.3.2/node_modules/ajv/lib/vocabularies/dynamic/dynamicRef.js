(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "../../compile/codegen", "../../compile/names", "../core/ref"], function (require, exports) {
    {
        CodeKeywordDefinition;
    }
    from;
    "../../types";
    {
        KeywordCxt;
    }
    from;
    "../../compile/validate";
    var codegen_1 = require("../../compile/codegen");
    var names_1 = require("../../compile/names");
    var ref_1 = require("../core/ref");
    var def = {
        keyword: "$dynamicRef",
        schemaType: "string",
        code: function (cxt) { return dynamicRef(cxt, cxt.schema); },
    };
    function dynamicRef(cxt, ref) {
        var gen = cxt.gen, keyword = cxt.keyword, it = cxt.it;
        if (ref[0] !== "#")
            throw new Error("\"" + keyword + "\" only supports hash fragment reference");
        var anchor = ref.slice(1);
        if (it.allErrors) {
            _dynamicRef();
        }
        else {
            var valid = gen.let("valid", false);
            _dynamicRef(valid);
            cxt.ok(valid);
        }
        function _dynamicRef(valid) {
            // TODO the assumption here is that `recursiveRef: #` always points to the root
            // of the schema object, which is not correct, because there may be $id that
            // makes # point to it, and the target schema may not contain dynamic/recursiveAnchor.
            // Because of that 2 tests in recursiveRef.json fail.
            // This is a similar problem to #815 (`$id` doesn't alter resolution scope for `{ "$ref": "#" }`).
            // (This problem is not tested in JSON-Schema-Test-Suite)
            if (it.schemaEnv.root.dynamicAnchors[anchor]) {
                var v = gen.let("_v", (_a = ["", "", ""], _a.raw = ["", "", ""], codegen_1._(_a, names_1.default.dynamicAnchors, codegen_1.getProperty(anchor))));
                gen.if(v, _callRef(v, valid), _callRef(it.validateName, valid));
            }
            else {
                _callRef(it.validateName, valid)();
            }
            var _a;
        }
        function _callRef(validate, valid) {
            return valid
                ? function () {
                    return gen.block(function () {
                        ref_1.callRef(cxt, validate);
                        gen.let(valid, true);
                    });
                }
                : function () { return ref_1.callRef(cxt, validate); };
        }
    }
    exports.dynamicRef = dynamicRef;
    exports.default = def;
});
