(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "../../compile/codegen"], function (require, exports) {
    {
        AddedFormat,
            FormatValidator,
            AsyncFormatValidator,
            CodeKeywordDefinition,
            KeywordErrorDefinition,
            ErrorObject,
        ;
    }
    from;
    "../../types";
    {
        KeywordCxt;
    }
    from;
    "../../compile/validate";
    var codegen_1 = require("../../compile/codegen");
    true;
    "format", { format: string }, string | { $data: string } >
    ;
    var error = {
        message: function (_a) {
            var schemaCode = _a.schemaCode;
            return (_b = ["must match format \"", "\""], _b.raw = ["must match format \"", "\""], codegen_1.str(_b, schemaCode));
            var _b;
        },
        params: function (_a) {
            var schemaCode = _a.schemaCode;
            return (_b = ["{format: ", "}"], _b.raw = ["{format: ", "}"], codegen_1._(_b, schemaCode));
            var _b;
        },
    };
    var def = {
        keyword: "format",
        type: ["number", "string"],
        schemaType: "string",
        $data: true,
        error: error,
        code: function (cxt, ruleType) {
            var gen = cxt.gen, data = cxt.data, $data = cxt.$data, schema = cxt.schema, schemaCode = cxt.schemaCode, it = cxt.it;
            var opts = it.opts, errSchemaPath = it.errSchemaPath, schemaEnv = it.schemaEnv, self = it.self;
            if (!opts.validateFormats)
                return;
            if ($data)
                validate$DataFormat();
            else
                validateFormat();
            function validate$DataFormat() {
                var fmts = gen.scopeValue("formats", {
                    ref: self.formats,
                    code: opts.code.formats,
                });
                var fDef = gen.const("fDef", (_a = ["", "[", "]"], _a.raw = ["", "[", "]"], codegen_1._(_a, fmts, schemaCode)));
                var fType = gen.let("fType");
                var format = gen.let("format");
                // TODO simplify
                gen.if((_b = ["typeof ", " == \"object\" && !(", " instanceof RegExp)"], _b.raw = ["typeof ", " == \"object\" && !(", " instanceof RegExp)"], codegen_1._(_b, fDef, fDef)), function () { return gen.assign(fType, (_a = ["", ".type || \"string\""], _a.raw = ["", ".type || \"string\""], codegen_1._(_a, fDef))).assign(format, (_b = ["", ".validate"], _b.raw = ["", ".validate"], codegen_1._(_b, fDef))); var _a, _b; }, function () { return gen.assign(fType, (_a = ["\"string\""], _a.raw = ["\"string\""], codegen_1._(_a))).assign(format, fDef); var _a; });
                cxt.fail$data(codegen_1.or(unknownFmt(), invalidFmt()));
                function unknownFmt() {
                    if (opts.strictSchema === false)
                        return codegen_1.nil;
                    return (_a = ["", " && !", ""], _a.raw = ["", " && !", ""], codegen_1._(_a, schemaCode, format));
                    var _a;
                }
                function invalidFmt() {
                    var callFormat = schemaEnv.$async
                        ? (_a = ["(", ".async ? await ", "(", ") : ", "(", "))"], _a.raw = ["(", ".async ? await ", "(", ") : ", "(", "))"], codegen_1._(_a, fDef, format, data, format, data))
                        : (_b = ["", "(", ")"], _b.raw = ["", "(", ")"], codegen_1._(_b, format, data));
                    var validData = (_c = ["(typeof ", " == \"function\" ? ", " : ", ".test(", "))"], _c.raw = ["(typeof ", " == \"function\" ? ", " : ", ".test(", "))"], codegen_1._(_c, format, callFormat, format, data));
                    return (_d = ["", " && ", " !== true && ", " === ", " && !", ""], _d.raw = ["", " && ", " !== true && ", " === ", " && !", ""], codegen_1._(_d, format, format, fType, ruleType, validData));
                    var _a, _b, _c, _d;
                }
                var _a, _b;
            }
            function validateFormat() {
                var formatDef = self.formats[schema];
                if (!formatDef) {
                    unknownFormat();
                    return;
                }
                if (formatDef === true)
                    return;
                var _a = getFormat(formatDef), fmtType = _a[0], format = _a[1], fmtRef = _a[2];
                if (fmtType === ruleType)
                    cxt.pass(validCondition());
                function unknownFormat() {
                    if (opts.strictSchema === false) {
                        self.logger.warn(unknownMsg());
                        return;
                    }
                    throw new Error(unknownMsg());
                    function unknownMsg() {
                        return "unknown format \"" + schema;
                        as;
                        string;
                    }
                    " ignored in schema at path ";
                    $;
                    {
                        errSchemaPath;
                    }
                    "`;
                }
            }
            function getFormat(fmtDef) {
                var code = fmtDef instanceof RegExp
                    ? codegen_1.regexpCode(fmtDef)
                    : opts.code.formats
                        ? (_a = ["", "", ""], _a.raw = ["", "", ""], codegen_1._(_a, opts.code.formats, codegen_1.getProperty(schema)))
                        : undefined;
                var fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code: code });
                if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
                    return [fmtDef.type || "string", fmtDef.validate, (_b = ["", ".validate"], _b.raw = ["", ".validate"], codegen_1._(_b, fmt))];
                }
                return ["string", fmtDef, fmt];
                var _a, _b;
            }
            function validCondition() {
                if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
                    if (!schemaEnv.$async)
                        throw new Error("async format in sync schema");
                    return (_a = ["await ", "(", ")"], _a.raw = ["await ", "(", ")"], codegen_1._(_a, fmtRef, data));
                }
                return typeof format == "function" ? (_b = ["", "(", ")"], _b.raw = ["", "(", ")"], codegen_1._(_b, fmtRef, data)) : (_c = ["", ".test(", ")"], _c.raw = ["", ".test(", ")"], codegen_1._(_c, fmtRef, data));
                var _a, _b, _c;
            }
        }
    };
    exports.default = def;
});
