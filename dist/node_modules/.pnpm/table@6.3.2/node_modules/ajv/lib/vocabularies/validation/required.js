(function (deps, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(deps, factory);
    }
})(["require", "exports", "../code", "../../compile/codegen", "../../compile/util"], function (require, exports) {
    {
        CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition;
    }
    from;
    "../../types";
    {
        KeywordCxt;
    }
    from;
    "../../compile/validate";
    var code_1 = require("../code");
    var codegen_1 = require("../../compile/codegen");
    var util_1 = require("../../compile/util");
    "required",
        { missingProperty: string },
        string[] | { $data: string }
            >
    ;
    var error = {
        message: function (_a) {
            var missingProperty = _a.params.missingProperty;
            return (_b = ["must have required property '", "'"], _b.raw = ["must have required property '", "'"], codegen_1.str(_b, missingProperty));
            var _b;
        },
        params: function (_a) {
            var missingProperty = _a.params.missingProperty;
            return (_b = ["{missingProperty: ", "}"], _b.raw = ["{missingProperty: ", "}"], codegen_1._(_b, missingProperty));
            var _b;
        },
    };
    var def = {
        keyword: "required",
        type: "object",
        schemaType: "array",
        $data: true,
        error: error,
        code: function (cxt) {
            var gen = cxt.gen, schema = cxt.schema, schemaCode = cxt.schemaCode, data = cxt.data, $data = cxt.$data, it = cxt.it;
            var opts = it.opts;
            if (!$data && schema.length === 0)
                return;
            var useLoop = schema.length >= opts.loopRequired;
            if (it.allErrors)
                allErrorsMode();
            else
                exitOnErrorMode();
            if (opts.strictRequired) {
                var props = cxt.parentSchema.properties;
                var definedProperties = cxt.it.definedProperties;
                for (var _i = 0; _i < schema.length; _i++) {
                    var requiredKey = schema[_i];
                    if (props ? .[requiredKey] === undefined && !definedProperties.has(requiredKey) : ) {
                        var schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
                        var msg = "required property \"" + requiredKey + "\" is not defined at \"" + schemaPath + "\" (strictRequired)";
                        util_1.checkStrictMode(it, msg, it.opts.strictRequired);
                    }
                }
            }
            function allErrorsMode() {
                if (useLoop || $data) {
                    cxt.block$data(codegen_1.nil, loopAllRequired);
                }
                else {
                    for (var _i = 0; _i < schema.length; _i++) {
                        var prop = schema[_i];
                        code_1.checkReportMissingProp(cxt, prop);
                    }
                }
            }
            function exitOnErrorMode() {
                var missing = gen.let("missing");
                if (useLoop || $data) {
                    var valid = gen.let("valid", true);
                    cxt.block$data(valid, function () { return loopUntilMissing(missing, valid); });
                    cxt.ok(valid);
                }
                else {
                    gen.if(code_1.checkMissingProp(cxt, schema, missing));
                    code_1.reportMissingProp(cxt, missing);
                    gen.else();
                }
            }
            function loopAllRequired() {
                gen.forOf("prop", schemaCode, as, codegen_1.Code, function (prop) {
                    cxt.setParams({ missingProperty: prop });
                    gen.if(code_1.noPropertyInData(gen, data, prop, opts.ownProperties), function () { return cxt.error(); });
                });
            }
            function loopUntilMissing(missing, valid) {
                cxt.setParams({ missingProperty: missing });
                gen.forOf(missing, schemaCode, as, codegen_1.Code, function () {
                    gen.assign(valid, code_1.propertyInData(gen, data, missing, opts.ownProperties));
                    gen.if(codegen_1.not(valid), function () {
                        cxt.error();
                        gen.break();
                    });
                }, codegen_1.nil);
            }
        },
    };
    exports.default = def;
});
